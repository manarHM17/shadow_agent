// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ota_service.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_ota_5fservice_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_ota_5fservice_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_ota_5fservice_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_ota_5fservice_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_ota_5fservice_2eproto;
namespace ota {
class DownloadRequest;
struct DownloadRequestDefaultTypeInternal;
extern DownloadRequestDefaultTypeInternal _DownloadRequest_default_instance_;
class DownloadResponse;
struct DownloadResponseDefaultTypeInternal;
extern DownloadResponseDefaultTypeInternal _DownloadResponse_default_instance_;
class FirmwareInfo;
struct FirmwareInfoDefaultTypeInternal;
extern FirmwareInfoDefaultTypeInternal _FirmwareInfo_default_instance_;
class UpdateCheckRequest;
struct UpdateCheckRequestDefaultTypeInternal;
extern UpdateCheckRequestDefaultTypeInternal _UpdateCheckRequest_default_instance_;
class UpdateCheckResponse;
struct UpdateCheckResponseDefaultTypeInternal;
extern UpdateCheckResponseDefaultTypeInternal _UpdateCheckResponse_default_instance_;
class UpdateStatusRequest;
struct UpdateStatusRequestDefaultTypeInternal;
extern UpdateStatusRequestDefaultTypeInternal _UpdateStatusRequest_default_instance_;
class UpdateStatusResponse;
struct UpdateStatusResponseDefaultTypeInternal;
extern UpdateStatusResponseDefaultTypeInternal _UpdateStatusResponse_default_instance_;
}  // namespace ota
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace ota {
enum UpdateStatus : int {
  IDLE = 0,
  DOWNLOADING = 1,
  DOWNLOAD_COMPLETED = 2,
  VERIFYING = 3,
  INSTALLING = 4,
  REBOOT_REQUIRED = 5,
  UPDATE_SUCCESS = 6,
  UPDATE_FAILED = 7,
  ROLLBACK_COMPLETED = 8,
  UpdateStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UpdateStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UpdateStatus_IsValid(int value);
extern const uint32_t UpdateStatus_internal_data_[];
constexpr UpdateStatus UpdateStatus_MIN = static_cast<UpdateStatus>(0);
constexpr UpdateStatus UpdateStatus_MAX = static_cast<UpdateStatus>(8);
constexpr int UpdateStatus_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor*
UpdateStatus_descriptor();
template <typename T>
const std::string& UpdateStatus_Name(T value) {
  static_assert(std::is_same<T, UpdateStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to UpdateStatus_Name().");
  return UpdateStatus_Name(static_cast<UpdateStatus>(value));
}
template <>
inline const std::string& UpdateStatus_Name(UpdateStatus value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UpdateStatus_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool UpdateStatus_Parse(absl::string_view name, UpdateStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UpdateStatus>(
      UpdateStatus_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class UpdateStatusResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ota.UpdateStatusResponse) */ {
 public:
  inline UpdateStatusResponse() : UpdateStatusResponse(nullptr) {}
  ~UpdateStatusResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateStatusResponse(::google::protobuf::internal::ConstantInitialized);

  inline UpdateStatusResponse(const UpdateStatusResponse& from)
      : UpdateStatusResponse(nullptr, from) {}
  UpdateStatusResponse(UpdateStatusResponse&& from) noexcept
    : UpdateStatusResponse() {
    *this = ::std::move(from);
  }

  inline UpdateStatusResponse& operator=(const UpdateStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateStatusResponse& operator=(UpdateStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateStatusResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateStatusResponse*>(
               &_UpdateStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UpdateStatusResponse& a, UpdateStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateStatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateStatusResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateStatusResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateStatusResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateStatusResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateStatusResponse& from) {
    UpdateStatusResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateStatusResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ota.UpdateStatusResponse";
  }
  protected:
  explicit UpdateStatusResponse(::google::protobuf::Arena* arena);
  UpdateStatusResponse(::google::protobuf::Arena* arena, const UpdateStatusResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kTimestampFieldNumber = 3,
    kAcknowledgedFieldNumber = 1,
  };
  // string message = 2;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // int64 timestamp = 3;
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // bool acknowledged = 1;
  void clear_acknowledged() ;
  bool acknowledged() const;
  void set_acknowledged(bool value);

  private:
  bool _internal_acknowledged() const;
  void _internal_set_acknowledged(bool value);

  public:
  // @@protoc_insertion_point(class_scope:ota.UpdateStatusResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      40, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::int64_t timestamp_;
    bool acknowledged_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ota_5fservice_2eproto;
};// -------------------------------------------------------------------

class UpdateStatusRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ota.UpdateStatusRequest) */ {
 public:
  inline UpdateStatusRequest() : UpdateStatusRequest(nullptr) {}
  ~UpdateStatusRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateStatusRequest(::google::protobuf::internal::ConstantInitialized);

  inline UpdateStatusRequest(const UpdateStatusRequest& from)
      : UpdateStatusRequest(nullptr, from) {}
  UpdateStatusRequest(UpdateStatusRequest&& from) noexcept
    : UpdateStatusRequest() {
    *this = ::std::move(from);
  }

  inline UpdateStatusRequest& operator=(const UpdateStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateStatusRequest& operator=(UpdateStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateStatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateStatusRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateStatusRequest*>(
               &_UpdateStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UpdateStatusRequest& a, UpdateStatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateStatusRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateStatusRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateStatusRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateStatusRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateStatusRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateStatusRequest& from) {
    UpdateStatusRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateStatusRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ota.UpdateStatusRequest";
  }
  protected:
  explicit UpdateStatusRequest(::google::protobuf::Arena* arena);
  UpdateStatusRequest(::google::protobuf::Arena* arena, const UpdateStatusRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFirmwareVersionFieldNumber = 2,
    kErrorMessageFieldNumber = 4,
    kDeviceIdFieldNumber = 1,
    kStatusFieldNumber = 3,
    kTimestampFieldNumber = 6,
    kProgressPercentageFieldNumber = 5,
  };
  // string firmware_version = 2;
  void clear_firmware_version() ;
  const std::string& firmware_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_firmware_version(Arg_&& arg, Args_... args);
  std::string* mutable_firmware_version();
  PROTOBUF_NODISCARD std::string* release_firmware_version();
  void set_allocated_firmware_version(std::string* value);

  private:
  const std::string& _internal_firmware_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_firmware_version(
      const std::string& value);
  std::string* _internal_mutable_firmware_version();

  public:
  // string error_message = 4;
  void clear_error_message() ;
  const std::string& error_message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_message(Arg_&& arg, Args_... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* value);

  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(
      const std::string& value);
  std::string* _internal_mutable_error_message();

  public:
  // int32 device_id = 1;
  void clear_device_id() ;
  ::int32_t device_id() const;
  void set_device_id(::int32_t value);

  private:
  ::int32_t _internal_device_id() const;
  void _internal_set_device_id(::int32_t value);

  public:
  // .ota.UpdateStatus status = 3;
  void clear_status() ;
  ::ota::UpdateStatus status() const;
  void set_status(::ota::UpdateStatus value);

  private:
  ::ota::UpdateStatus _internal_status() const;
  void _internal_set_status(::ota::UpdateStatus value);

  public:
  // int64 timestamp = 6;
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // int32 progress_percentage = 5;
  void clear_progress_percentage() ;
  ::int32_t progress_percentage() const;
  void set_progress_percentage(::int32_t value);

  private:
  ::int32_t _internal_progress_percentage() const;
  void _internal_set_progress_percentage(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ota.UpdateStatusRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      61, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr firmware_version_;
    ::google::protobuf::internal::ArenaStringPtr error_message_;
    ::int32_t device_id_;
    int status_;
    ::int64_t timestamp_;
    ::int32_t progress_percentage_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ota_5fservice_2eproto;
};// -------------------------------------------------------------------

class UpdateCheckRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ota.UpdateCheckRequest) */ {
 public:
  inline UpdateCheckRequest() : UpdateCheckRequest(nullptr) {}
  ~UpdateCheckRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateCheckRequest(::google::protobuf::internal::ConstantInitialized);

  inline UpdateCheckRequest(const UpdateCheckRequest& from)
      : UpdateCheckRequest(nullptr, from) {}
  UpdateCheckRequest(UpdateCheckRequest&& from) noexcept
    : UpdateCheckRequest() {
    *this = ::std::move(from);
  }

  inline UpdateCheckRequest& operator=(const UpdateCheckRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateCheckRequest& operator=(UpdateCheckRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateCheckRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateCheckRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateCheckRequest*>(
               &_UpdateCheckRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(UpdateCheckRequest& a, UpdateCheckRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateCheckRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateCheckRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateCheckRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateCheckRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateCheckRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateCheckRequest& from) {
    UpdateCheckRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateCheckRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ota.UpdateCheckRequest";
  }
  protected:
  explicit UpdateCheckRequest(::google::protobuf::Arena* arena);
  UpdateCheckRequest(::google::protobuf::Arena* arena, const UpdateCheckRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrentVersionFieldNumber = 2,
    kHardwareModelFieldNumber = 3,
    kTimestampFieldNumber = 4,
    kDeviceIdFieldNumber = 1,
  };
  // string current_version = 2;
  void clear_current_version() ;
  const std::string& current_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_current_version(Arg_&& arg, Args_... args);
  std::string* mutable_current_version();
  PROTOBUF_NODISCARD std::string* release_current_version();
  void set_allocated_current_version(std::string* value);

  private:
  const std::string& _internal_current_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_current_version(
      const std::string& value);
  std::string* _internal_mutable_current_version();

  public:
  // string hardware_model = 3;
  void clear_hardware_model() ;
  const std::string& hardware_model() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hardware_model(Arg_&& arg, Args_... args);
  std::string* mutable_hardware_model();
  PROTOBUF_NODISCARD std::string* release_hardware_model();
  void set_allocated_hardware_model(std::string* value);

  private:
  const std::string& _internal_hardware_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hardware_model(
      const std::string& value);
  std::string* _internal_mutable_hardware_model();

  public:
  // int64 timestamp = 4;
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // int32 device_id = 1;
  void clear_device_id() ;
  ::int32_t device_id() const;
  void set_device_id(::int32_t value);

  private:
  ::int32_t _internal_device_id() const;
  void _internal_set_device_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ota.UpdateCheckRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      60, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr current_version_;
    ::google::protobuf::internal::ArenaStringPtr hardware_model_;
    ::int64_t timestamp_;
    ::int32_t device_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ota_5fservice_2eproto;
};// -------------------------------------------------------------------

class FirmwareInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ota.FirmwareInfo) */ {
 public:
  inline FirmwareInfo() : FirmwareInfo(nullptr) {}
  ~FirmwareInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FirmwareInfo(::google::protobuf::internal::ConstantInitialized);

  inline FirmwareInfo(const FirmwareInfo& from)
      : FirmwareInfo(nullptr, from) {}
  FirmwareInfo(FirmwareInfo&& from) noexcept
    : FirmwareInfo() {
    *this = ::std::move(from);
  }

  inline FirmwareInfo& operator=(const FirmwareInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline FirmwareInfo& operator=(FirmwareInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FirmwareInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const FirmwareInfo* internal_default_instance() {
    return reinterpret_cast<const FirmwareInfo*>(
               &_FirmwareInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FirmwareInfo& a, FirmwareInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(FirmwareInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FirmwareInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FirmwareInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FirmwareInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FirmwareInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const FirmwareInfo& from) {
    FirmwareInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FirmwareInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ota.FirmwareInfo";
  }
  protected:
  explicit FirmwareInfo(::google::protobuf::Arena* arena);
  FirmwareInfo(::google::protobuf::Arena* arena, const FirmwareInfo& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kFilenameFieldNumber = 2,
    kChecksumFieldNumber = 4,
    kReleaseNotesFieldNumber = 5,
    kFileSizeFieldNumber = 3,
    kIsCriticalFieldNumber = 6,
  };
  // string version = 1;
  void clear_version() ;
  const std::string& version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_version(Arg_&& arg, Args_... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* value);

  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(
      const std::string& value);
  std::string* _internal_mutable_version();

  public:
  // string filename = 2;
  void clear_filename() ;
  const std::string& filename() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_filename(Arg_&& arg, Args_... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* value);

  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(
      const std::string& value);
  std::string* _internal_mutable_filename();

  public:
  // string checksum = 4;
  void clear_checksum() ;
  const std::string& checksum() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_checksum(Arg_&& arg, Args_... args);
  std::string* mutable_checksum();
  PROTOBUF_NODISCARD std::string* release_checksum();
  void set_allocated_checksum(std::string* value);

  private:
  const std::string& _internal_checksum() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_checksum(
      const std::string& value);
  std::string* _internal_mutable_checksum();

  public:
  // string release_notes = 5;
  void clear_release_notes() ;
  const std::string& release_notes() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_release_notes(Arg_&& arg, Args_... args);
  std::string* mutable_release_notes();
  PROTOBUF_NODISCARD std::string* release_release_notes();
  void set_allocated_release_notes(std::string* value);

  private:
  const std::string& _internal_release_notes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_release_notes(
      const std::string& value);
  std::string* _internal_mutable_release_notes();

  public:
  // int64 file_size = 3;
  void clear_file_size() ;
  ::int64_t file_size() const;
  void set_file_size(::int64_t value);

  private:
  ::int64_t _internal_file_size() const;
  void _internal_set_file_size(::int64_t value);

  public:
  // bool is_critical = 6;
  void clear_is_critical() ;
  bool is_critical() const;
  void set_is_critical(bool value);

  private:
  bool _internal_is_critical() const;
  void _internal_set_is_critical(bool value);

  public:
  // @@protoc_insertion_point(class_scope:ota.FirmwareInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      61, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr version_;
    ::google::protobuf::internal::ArenaStringPtr filename_;
    ::google::protobuf::internal::ArenaStringPtr checksum_;
    ::google::protobuf::internal::ArenaStringPtr release_notes_;
    ::int64_t file_size_;
    bool is_critical_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ota_5fservice_2eproto;
};// -------------------------------------------------------------------

class DownloadResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ota.DownloadResponse) */ {
 public:
  inline DownloadResponse() : DownloadResponse(nullptr) {}
  ~DownloadResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DownloadResponse(::google::protobuf::internal::ConstantInitialized);

  inline DownloadResponse(const DownloadResponse& from)
      : DownloadResponse(nullptr, from) {}
  DownloadResponse(DownloadResponse&& from) noexcept
    : DownloadResponse() {
    *this = ::std::move(from);
  }

  inline DownloadResponse& operator=(const DownloadResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadResponse& operator=(DownloadResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DownloadResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DownloadResponse* internal_default_instance() {
    return reinterpret_cast<const DownloadResponse*>(
               &_DownloadResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DownloadResponse& a, DownloadResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DownloadResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DownloadResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DownloadResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DownloadResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DownloadResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DownloadResponse& from) {
    DownloadResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DownloadResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ota.DownloadResponse";
  }
  protected:
  explicit DownloadResponse(::google::protobuf::Arena* arena);
  DownloadResponse(::google::protobuf::Arena* arena, const DownloadResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kOffsetFieldNumber = 2,
    kTotalSizeFieldNumber = 3,
    kIsLastChunkFieldNumber = 4,
  };
  // bytes data = 1;
  void clear_data() ;
  const std::string& data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* value);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // int64 offset = 2;
  void clear_offset() ;
  ::int64_t offset() const;
  void set_offset(::int64_t value);

  private:
  ::int64_t _internal_offset() const;
  void _internal_set_offset(::int64_t value);

  public:
  // int64 total_size = 3;
  void clear_total_size() ;
  ::int64_t total_size() const;
  void set_total_size(::int64_t value);

  private:
  ::int64_t _internal_total_size() const;
  void _internal_set_total_size(::int64_t value);

  public:
  // bool is_last_chunk = 4;
  void clear_is_last_chunk() ;
  bool is_last_chunk() const;
  void set_is_last_chunk(bool value);

  private:
  bool _internal_is_last_chunk() const;
  void _internal_set_is_last_chunk(bool value);

  public:
  // @@protoc_insertion_point(class_scope:ota.DownloadResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr data_;
    ::int64_t offset_;
    ::int64_t total_size_;
    bool is_last_chunk_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ota_5fservice_2eproto;
};// -------------------------------------------------------------------

class DownloadRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ota.DownloadRequest) */ {
 public:
  inline DownloadRequest() : DownloadRequest(nullptr) {}
  ~DownloadRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DownloadRequest(::google::protobuf::internal::ConstantInitialized);

  inline DownloadRequest(const DownloadRequest& from)
      : DownloadRequest(nullptr, from) {}
  DownloadRequest(DownloadRequest&& from) noexcept
    : DownloadRequest() {
    *this = ::std::move(from);
  }

  inline DownloadRequest& operator=(const DownloadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadRequest& operator=(DownloadRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DownloadRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DownloadRequest* internal_default_instance() {
    return reinterpret_cast<const DownloadRequest*>(
               &_DownloadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DownloadRequest& a, DownloadRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DownloadRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DownloadRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DownloadRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DownloadRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DownloadRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DownloadRequest& from) {
    DownloadRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DownloadRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ota.DownloadRequest";
  }
  protected:
  explicit DownloadRequest(::google::protobuf::Arena* arena);
  DownloadRequest(::google::protobuf::Arena* arena, const DownloadRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFirmwareVersionFieldNumber = 2,
    kOffsetFieldNumber = 3,
    kDeviceIdFieldNumber = 1,
  };
  // string firmware_version = 2;
  void clear_firmware_version() ;
  const std::string& firmware_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_firmware_version(Arg_&& arg, Args_... args);
  std::string* mutable_firmware_version();
  PROTOBUF_NODISCARD std::string* release_firmware_version();
  void set_allocated_firmware_version(std::string* value);

  private:
  const std::string& _internal_firmware_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_firmware_version(
      const std::string& value);
  std::string* _internal_mutable_firmware_version();

  public:
  // int64 offset = 3;
  void clear_offset() ;
  ::int64_t offset() const;
  void set_offset(::int64_t value);

  private:
  ::int64_t _internal_offset() const;
  void _internal_set_offset(::int64_t value);

  public:
  // int32 device_id = 1;
  void clear_device_id() ;
  ::int32_t device_id() const;
  void set_device_id(::int32_t value);

  private:
  ::int32_t _internal_device_id() const;
  void _internal_set_device_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ota.DownloadRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      44, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr firmware_version_;
    ::int64_t offset_;
    ::int32_t device_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ota_5fservice_2eproto;
};// -------------------------------------------------------------------

class UpdateCheckResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ota.UpdateCheckResponse) */ {
 public:
  inline UpdateCheckResponse() : UpdateCheckResponse(nullptr) {}
  ~UpdateCheckResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateCheckResponse(::google::protobuf::internal::ConstantInitialized);

  inline UpdateCheckResponse(const UpdateCheckResponse& from)
      : UpdateCheckResponse(nullptr, from) {}
  UpdateCheckResponse(UpdateCheckResponse&& from) noexcept
    : UpdateCheckResponse() {
    *this = ::std::move(from);
  }

  inline UpdateCheckResponse& operator=(const UpdateCheckResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateCheckResponse& operator=(UpdateCheckResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateCheckResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateCheckResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateCheckResponse*>(
               &_UpdateCheckResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(UpdateCheckResponse& a, UpdateCheckResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateCheckResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateCheckResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateCheckResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateCheckResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateCheckResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateCheckResponse& from) {
    UpdateCheckResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateCheckResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ota.UpdateCheckResponse";
  }
  protected:
  explicit UpdateCheckResponse(::google::protobuf::Arena* arena);
  UpdateCheckResponse(::google::protobuf::Arena* arena, const UpdateCheckResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFirmwareInfoFieldNumber = 2,
    kTimestampFieldNumber = 3,
    kUpdateAvailableFieldNumber = 1,
  };
  // .ota.FirmwareInfo firmware_info = 2;
  bool has_firmware_info() const;
  void clear_firmware_info() ;
  const ::ota::FirmwareInfo& firmware_info() const;
  PROTOBUF_NODISCARD ::ota::FirmwareInfo* release_firmware_info();
  ::ota::FirmwareInfo* mutable_firmware_info();
  void set_allocated_firmware_info(::ota::FirmwareInfo* value);
  void unsafe_arena_set_allocated_firmware_info(::ota::FirmwareInfo* value);
  ::ota::FirmwareInfo* unsafe_arena_release_firmware_info();

  private:
  const ::ota::FirmwareInfo& _internal_firmware_info() const;
  ::ota::FirmwareInfo* _internal_mutable_firmware_info();

  public:
  // int64 timestamp = 3;
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // bool update_available = 1;
  void clear_update_available() ;
  bool update_available() const;
  void set_update_available(bool value);

  private:
  bool _internal_update_available() const;
  void _internal_set_update_available(bool value);

  public:
  // @@protoc_insertion_point(class_scope:ota.UpdateCheckResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::ota::FirmwareInfo* firmware_info_;
    ::int64_t timestamp_;
    bool update_available_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ota_5fservice_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// UpdateCheckRequest

// int32 device_id = 1;
inline void UpdateCheckRequest::clear_device_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_id_ = 0;
}
inline ::int32_t UpdateCheckRequest::device_id() const {
  // @@protoc_insertion_point(field_get:ota.UpdateCheckRequest.device_id)
  return _internal_device_id();
}
inline void UpdateCheckRequest::set_device_id(::int32_t value) {
  _internal_set_device_id(value);
  // @@protoc_insertion_point(field_set:ota.UpdateCheckRequest.device_id)
}
inline ::int32_t UpdateCheckRequest::_internal_device_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.device_id_;
}
inline void UpdateCheckRequest::_internal_set_device_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_id_ = value;
}

// string current_version = 2;
inline void UpdateCheckRequest::clear_current_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.current_version_.ClearToEmpty();
}
inline const std::string& UpdateCheckRequest::current_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ota.UpdateCheckRequest.current_version)
  return _internal_current_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateCheckRequest::set_current_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.current_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ota.UpdateCheckRequest.current_version)
}
inline std::string* UpdateCheckRequest::mutable_current_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_current_version();
  // @@protoc_insertion_point(field_mutable:ota.UpdateCheckRequest.current_version)
  return _s;
}
inline const std::string& UpdateCheckRequest::_internal_current_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.current_version_.Get();
}
inline void UpdateCheckRequest::_internal_set_current_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.current_version_.Set(value, GetArena());
}
inline std::string* UpdateCheckRequest::_internal_mutable_current_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.current_version_.Mutable( GetArena());
}
inline std::string* UpdateCheckRequest::release_current_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ota.UpdateCheckRequest.current_version)
  return _impl_.current_version_.Release();
}
inline void UpdateCheckRequest::set_allocated_current_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.current_version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.current_version_.IsDefault()) {
          _impl_.current_version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ota.UpdateCheckRequest.current_version)
}

// string hardware_model = 3;
inline void UpdateCheckRequest::clear_hardware_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hardware_model_.ClearToEmpty();
}
inline const std::string& UpdateCheckRequest::hardware_model() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ota.UpdateCheckRequest.hardware_model)
  return _internal_hardware_model();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateCheckRequest::set_hardware_model(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.hardware_model_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ota.UpdateCheckRequest.hardware_model)
}
inline std::string* UpdateCheckRequest::mutable_hardware_model() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_hardware_model();
  // @@protoc_insertion_point(field_mutable:ota.UpdateCheckRequest.hardware_model)
  return _s;
}
inline const std::string& UpdateCheckRequest::_internal_hardware_model() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hardware_model_.Get();
}
inline void UpdateCheckRequest::_internal_set_hardware_model(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.hardware_model_.Set(value, GetArena());
}
inline std::string* UpdateCheckRequest::_internal_mutable_hardware_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.hardware_model_.Mutable( GetArena());
}
inline std::string* UpdateCheckRequest::release_hardware_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ota.UpdateCheckRequest.hardware_model)
  return _impl_.hardware_model_.Release();
}
inline void UpdateCheckRequest::set_allocated_hardware_model(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hardware_model_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.hardware_model_.IsDefault()) {
          _impl_.hardware_model_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ota.UpdateCheckRequest.hardware_model)
}

// int64 timestamp = 4;
inline void UpdateCheckRequest::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::int64_t{0};
}
inline ::int64_t UpdateCheckRequest::timestamp() const {
  // @@protoc_insertion_point(field_get:ota.UpdateCheckRequest.timestamp)
  return _internal_timestamp();
}
inline void UpdateCheckRequest::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:ota.UpdateCheckRequest.timestamp)
}
inline ::int64_t UpdateCheckRequest::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void UpdateCheckRequest::_internal_set_timestamp(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// -------------------------------------------------------------------

// UpdateCheckResponse

// bool update_available = 1;
inline void UpdateCheckResponse::clear_update_available() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.update_available_ = false;
}
inline bool UpdateCheckResponse::update_available() const {
  // @@protoc_insertion_point(field_get:ota.UpdateCheckResponse.update_available)
  return _internal_update_available();
}
inline void UpdateCheckResponse::set_update_available(bool value) {
  _internal_set_update_available(value);
  // @@protoc_insertion_point(field_set:ota.UpdateCheckResponse.update_available)
}
inline bool UpdateCheckResponse::_internal_update_available() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.update_available_;
}
inline void UpdateCheckResponse::_internal_set_update_available(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.update_available_ = value;
}

// .ota.FirmwareInfo firmware_info = 2;
inline bool UpdateCheckResponse::has_firmware_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.firmware_info_ != nullptr);
  return value;
}
inline void UpdateCheckResponse::clear_firmware_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.firmware_info_ != nullptr) _impl_.firmware_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ota::FirmwareInfo& UpdateCheckResponse::_internal_firmware_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ota::FirmwareInfo* p = _impl_.firmware_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::ota::FirmwareInfo&>(::ota::_FirmwareInfo_default_instance_);
}
inline const ::ota::FirmwareInfo& UpdateCheckResponse::firmware_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ota.UpdateCheckResponse.firmware_info)
  return _internal_firmware_info();
}
inline void UpdateCheckResponse::unsafe_arena_set_allocated_firmware_info(::ota::FirmwareInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.firmware_info_);
  }
  _impl_.firmware_info_ = reinterpret_cast<::ota::FirmwareInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ota.UpdateCheckResponse.firmware_info)
}
inline ::ota::FirmwareInfo* UpdateCheckResponse::release_firmware_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ota::FirmwareInfo* released = _impl_.firmware_info_;
  _impl_.firmware_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ota::FirmwareInfo* UpdateCheckResponse::unsafe_arena_release_firmware_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ota.UpdateCheckResponse.firmware_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ota::FirmwareInfo* temp = _impl_.firmware_info_;
  _impl_.firmware_info_ = nullptr;
  return temp;
}
inline ::ota::FirmwareInfo* UpdateCheckResponse::_internal_mutable_firmware_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.firmware_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::ota::FirmwareInfo>(GetArena());
    _impl_.firmware_info_ = reinterpret_cast<::ota::FirmwareInfo*>(p);
  }
  return _impl_.firmware_info_;
}
inline ::ota::FirmwareInfo* UpdateCheckResponse::mutable_firmware_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ota::FirmwareInfo* _msg = _internal_mutable_firmware_info();
  // @@protoc_insertion_point(field_mutable:ota.UpdateCheckResponse.firmware_info)
  return _msg;
}
inline void UpdateCheckResponse::set_allocated_firmware_info(::ota::FirmwareInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::ota::FirmwareInfo*>(_impl_.firmware_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::ota::FirmwareInfo*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.firmware_info_ = reinterpret_cast<::ota::FirmwareInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:ota.UpdateCheckResponse.firmware_info)
}

// int64 timestamp = 3;
inline void UpdateCheckResponse::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::int64_t{0};
}
inline ::int64_t UpdateCheckResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:ota.UpdateCheckResponse.timestamp)
  return _internal_timestamp();
}
inline void UpdateCheckResponse::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:ota.UpdateCheckResponse.timestamp)
}
inline ::int64_t UpdateCheckResponse::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void UpdateCheckResponse::_internal_set_timestamp(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// -------------------------------------------------------------------

// FirmwareInfo

// string version = 1;
inline void FirmwareInfo::clear_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.version_.ClearToEmpty();
}
inline const std::string& FirmwareInfo::version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ota.FirmwareInfo.version)
  return _internal_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FirmwareInfo::set_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ota.FirmwareInfo.version)
}
inline std::string* FirmwareInfo::mutable_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:ota.FirmwareInfo.version)
  return _s;
}
inline const std::string& FirmwareInfo::_internal_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.version_.Get();
}
inline void FirmwareInfo::_internal_set_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.version_.Set(value, GetArena());
}
inline std::string* FirmwareInfo::_internal_mutable_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.version_.Mutable( GetArena());
}
inline std::string* FirmwareInfo::release_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ota.FirmwareInfo.version)
  return _impl_.version_.Release();
}
inline void FirmwareInfo::set_allocated_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.version_.IsDefault()) {
          _impl_.version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ota.FirmwareInfo.version)
}

// string filename = 2;
inline void FirmwareInfo::clear_filename() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.filename_.ClearToEmpty();
}
inline const std::string& FirmwareInfo::filename() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ota.FirmwareInfo.filename)
  return _internal_filename();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FirmwareInfo::set_filename(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.filename_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ota.FirmwareInfo.filename)
}
inline std::string* FirmwareInfo::mutable_filename() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:ota.FirmwareInfo.filename)
  return _s;
}
inline const std::string& FirmwareInfo::_internal_filename() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.filename_.Get();
}
inline void FirmwareInfo::_internal_set_filename(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.filename_.Set(value, GetArena());
}
inline std::string* FirmwareInfo::_internal_mutable_filename() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.filename_.Mutable( GetArena());
}
inline std::string* FirmwareInfo::release_filename() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ota.FirmwareInfo.filename)
  return _impl_.filename_.Release();
}
inline void FirmwareInfo::set_allocated_filename(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.filename_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.filename_.IsDefault()) {
          _impl_.filename_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ota.FirmwareInfo.filename)
}

// int64 file_size = 3;
inline void FirmwareInfo::clear_file_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.file_size_ = ::int64_t{0};
}
inline ::int64_t FirmwareInfo::file_size() const {
  // @@protoc_insertion_point(field_get:ota.FirmwareInfo.file_size)
  return _internal_file_size();
}
inline void FirmwareInfo::set_file_size(::int64_t value) {
  _internal_set_file_size(value);
  // @@protoc_insertion_point(field_set:ota.FirmwareInfo.file_size)
}
inline ::int64_t FirmwareInfo::_internal_file_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.file_size_;
}
inline void FirmwareInfo::_internal_set_file_size(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.file_size_ = value;
}

// string checksum = 4;
inline void FirmwareInfo::clear_checksum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.checksum_.ClearToEmpty();
}
inline const std::string& FirmwareInfo::checksum() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ota.FirmwareInfo.checksum)
  return _internal_checksum();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FirmwareInfo::set_checksum(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.checksum_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ota.FirmwareInfo.checksum)
}
inline std::string* FirmwareInfo::mutable_checksum() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_checksum();
  // @@protoc_insertion_point(field_mutable:ota.FirmwareInfo.checksum)
  return _s;
}
inline const std::string& FirmwareInfo::_internal_checksum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.checksum_.Get();
}
inline void FirmwareInfo::_internal_set_checksum(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.checksum_.Set(value, GetArena());
}
inline std::string* FirmwareInfo::_internal_mutable_checksum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.checksum_.Mutable( GetArena());
}
inline std::string* FirmwareInfo::release_checksum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ota.FirmwareInfo.checksum)
  return _impl_.checksum_.Release();
}
inline void FirmwareInfo::set_allocated_checksum(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.checksum_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.checksum_.IsDefault()) {
          _impl_.checksum_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ota.FirmwareInfo.checksum)
}

// string release_notes = 5;
inline void FirmwareInfo::clear_release_notes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.release_notes_.ClearToEmpty();
}
inline const std::string& FirmwareInfo::release_notes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ota.FirmwareInfo.release_notes)
  return _internal_release_notes();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FirmwareInfo::set_release_notes(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.release_notes_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ota.FirmwareInfo.release_notes)
}
inline std::string* FirmwareInfo::mutable_release_notes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_release_notes();
  // @@protoc_insertion_point(field_mutable:ota.FirmwareInfo.release_notes)
  return _s;
}
inline const std::string& FirmwareInfo::_internal_release_notes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.release_notes_.Get();
}
inline void FirmwareInfo::_internal_set_release_notes(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.release_notes_.Set(value, GetArena());
}
inline std::string* FirmwareInfo::_internal_mutable_release_notes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.release_notes_.Mutable( GetArena());
}
inline std::string* FirmwareInfo::release_release_notes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ota.FirmwareInfo.release_notes)
  return _impl_.release_notes_.Release();
}
inline void FirmwareInfo::set_allocated_release_notes(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.release_notes_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.release_notes_.IsDefault()) {
          _impl_.release_notes_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ota.FirmwareInfo.release_notes)
}

// bool is_critical = 6;
inline void FirmwareInfo::clear_is_critical() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_critical_ = false;
}
inline bool FirmwareInfo::is_critical() const {
  // @@protoc_insertion_point(field_get:ota.FirmwareInfo.is_critical)
  return _internal_is_critical();
}
inline void FirmwareInfo::set_is_critical(bool value) {
  _internal_set_is_critical(value);
  // @@protoc_insertion_point(field_set:ota.FirmwareInfo.is_critical)
}
inline bool FirmwareInfo::_internal_is_critical() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_critical_;
}
inline void FirmwareInfo::_internal_set_is_critical(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_critical_ = value;
}

// -------------------------------------------------------------------

// DownloadRequest

// int32 device_id = 1;
inline void DownloadRequest::clear_device_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_id_ = 0;
}
inline ::int32_t DownloadRequest::device_id() const {
  // @@protoc_insertion_point(field_get:ota.DownloadRequest.device_id)
  return _internal_device_id();
}
inline void DownloadRequest::set_device_id(::int32_t value) {
  _internal_set_device_id(value);
  // @@protoc_insertion_point(field_set:ota.DownloadRequest.device_id)
}
inline ::int32_t DownloadRequest::_internal_device_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.device_id_;
}
inline void DownloadRequest::_internal_set_device_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_id_ = value;
}

// string firmware_version = 2;
inline void DownloadRequest::clear_firmware_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.firmware_version_.ClearToEmpty();
}
inline const std::string& DownloadRequest::firmware_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ota.DownloadRequest.firmware_version)
  return _internal_firmware_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DownloadRequest::set_firmware_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.firmware_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ota.DownloadRequest.firmware_version)
}
inline std::string* DownloadRequest::mutable_firmware_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_firmware_version();
  // @@protoc_insertion_point(field_mutable:ota.DownloadRequest.firmware_version)
  return _s;
}
inline const std::string& DownloadRequest::_internal_firmware_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.firmware_version_.Get();
}
inline void DownloadRequest::_internal_set_firmware_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.firmware_version_.Set(value, GetArena());
}
inline std::string* DownloadRequest::_internal_mutable_firmware_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.firmware_version_.Mutable( GetArena());
}
inline std::string* DownloadRequest::release_firmware_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ota.DownloadRequest.firmware_version)
  return _impl_.firmware_version_.Release();
}
inline void DownloadRequest::set_allocated_firmware_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.firmware_version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.firmware_version_.IsDefault()) {
          _impl_.firmware_version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ota.DownloadRequest.firmware_version)
}

// int64 offset = 3;
inline void DownloadRequest::clear_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.offset_ = ::int64_t{0};
}
inline ::int64_t DownloadRequest::offset() const {
  // @@protoc_insertion_point(field_get:ota.DownloadRequest.offset)
  return _internal_offset();
}
inline void DownloadRequest::set_offset(::int64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:ota.DownloadRequest.offset)
}
inline ::int64_t DownloadRequest::_internal_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.offset_;
}
inline void DownloadRequest::_internal_set_offset(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.offset_ = value;
}

// -------------------------------------------------------------------

// DownloadResponse

// bytes data = 1;
inline void DownloadResponse::clear_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.ClearToEmpty();
}
inline const std::string& DownloadResponse::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ota.DownloadResponse.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DownloadResponse::set_data(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ota.DownloadResponse.data)
}
inline std::string* DownloadResponse::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:ota.DownloadResponse.data)
  return _s;
}
inline const std::string& DownloadResponse::_internal_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_.Get();
}
inline void DownloadResponse::_internal_set_data(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.data_.Set(value, GetArena());
}
inline std::string* DownloadResponse::_internal_mutable_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.data_.Mutable( GetArena());
}
inline std::string* DownloadResponse::release_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ota.DownloadResponse.data)
  return _impl_.data_.Release();
}
inline void DownloadResponse::set_allocated_data(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_.IsDefault()) {
          _impl_.data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ota.DownloadResponse.data)
}

// int64 offset = 2;
inline void DownloadResponse::clear_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.offset_ = ::int64_t{0};
}
inline ::int64_t DownloadResponse::offset() const {
  // @@protoc_insertion_point(field_get:ota.DownloadResponse.offset)
  return _internal_offset();
}
inline void DownloadResponse::set_offset(::int64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:ota.DownloadResponse.offset)
}
inline ::int64_t DownloadResponse::_internal_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.offset_;
}
inline void DownloadResponse::_internal_set_offset(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.offset_ = value;
}

// int64 total_size = 3;
inline void DownloadResponse::clear_total_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.total_size_ = ::int64_t{0};
}
inline ::int64_t DownloadResponse::total_size() const {
  // @@protoc_insertion_point(field_get:ota.DownloadResponse.total_size)
  return _internal_total_size();
}
inline void DownloadResponse::set_total_size(::int64_t value) {
  _internal_set_total_size(value);
  // @@protoc_insertion_point(field_set:ota.DownloadResponse.total_size)
}
inline ::int64_t DownloadResponse::_internal_total_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_size_;
}
inline void DownloadResponse::_internal_set_total_size(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.total_size_ = value;
}

// bool is_last_chunk = 4;
inline void DownloadResponse::clear_is_last_chunk() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_last_chunk_ = false;
}
inline bool DownloadResponse::is_last_chunk() const {
  // @@protoc_insertion_point(field_get:ota.DownloadResponse.is_last_chunk)
  return _internal_is_last_chunk();
}
inline void DownloadResponse::set_is_last_chunk(bool value) {
  _internal_set_is_last_chunk(value);
  // @@protoc_insertion_point(field_set:ota.DownloadResponse.is_last_chunk)
}
inline bool DownloadResponse::_internal_is_last_chunk() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_last_chunk_;
}
inline void DownloadResponse::_internal_set_is_last_chunk(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_last_chunk_ = value;
}

// -------------------------------------------------------------------

// UpdateStatusRequest

// int32 device_id = 1;
inline void UpdateStatusRequest::clear_device_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_id_ = 0;
}
inline ::int32_t UpdateStatusRequest::device_id() const {
  // @@protoc_insertion_point(field_get:ota.UpdateStatusRequest.device_id)
  return _internal_device_id();
}
inline void UpdateStatusRequest::set_device_id(::int32_t value) {
  _internal_set_device_id(value);
  // @@protoc_insertion_point(field_set:ota.UpdateStatusRequest.device_id)
}
inline ::int32_t UpdateStatusRequest::_internal_device_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.device_id_;
}
inline void UpdateStatusRequest::_internal_set_device_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_id_ = value;
}

// string firmware_version = 2;
inline void UpdateStatusRequest::clear_firmware_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.firmware_version_.ClearToEmpty();
}
inline const std::string& UpdateStatusRequest::firmware_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ota.UpdateStatusRequest.firmware_version)
  return _internal_firmware_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateStatusRequest::set_firmware_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.firmware_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ota.UpdateStatusRequest.firmware_version)
}
inline std::string* UpdateStatusRequest::mutable_firmware_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_firmware_version();
  // @@protoc_insertion_point(field_mutable:ota.UpdateStatusRequest.firmware_version)
  return _s;
}
inline const std::string& UpdateStatusRequest::_internal_firmware_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.firmware_version_.Get();
}
inline void UpdateStatusRequest::_internal_set_firmware_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.firmware_version_.Set(value, GetArena());
}
inline std::string* UpdateStatusRequest::_internal_mutable_firmware_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.firmware_version_.Mutable( GetArena());
}
inline std::string* UpdateStatusRequest::release_firmware_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ota.UpdateStatusRequest.firmware_version)
  return _impl_.firmware_version_.Release();
}
inline void UpdateStatusRequest::set_allocated_firmware_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.firmware_version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.firmware_version_.IsDefault()) {
          _impl_.firmware_version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ota.UpdateStatusRequest.firmware_version)
}

// .ota.UpdateStatus status = 3;
inline void UpdateStatusRequest::clear_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_ = 0;
}
inline ::ota::UpdateStatus UpdateStatusRequest::status() const {
  // @@protoc_insertion_point(field_get:ota.UpdateStatusRequest.status)
  return _internal_status();
}
inline void UpdateStatusRequest::set_status(::ota::UpdateStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:ota.UpdateStatusRequest.status)
}
inline ::ota::UpdateStatus UpdateStatusRequest::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::ota::UpdateStatus>(_impl_.status_);
}
inline void UpdateStatusRequest::_internal_set_status(::ota::UpdateStatus value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.status_ = value;
}

// string error_message = 4;
inline void UpdateStatusRequest::clear_error_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& UpdateStatusRequest::error_message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ota.UpdateStatusRequest.error_message)
  return _internal_error_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateStatusRequest::set_error_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.error_message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ota.UpdateStatusRequest.error_message)
}
inline std::string* UpdateStatusRequest::mutable_error_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:ota.UpdateStatusRequest.error_message)
  return _s;
}
inline const std::string& UpdateStatusRequest::_internal_error_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.error_message_.Get();
}
inline void UpdateStatusRequest::_internal_set_error_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.error_message_.Set(value, GetArena());
}
inline std::string* UpdateStatusRequest::_internal_mutable_error_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.error_message_.Mutable( GetArena());
}
inline std::string* UpdateStatusRequest::release_error_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ota.UpdateStatusRequest.error_message)
  return _impl_.error_message_.Release();
}
inline void UpdateStatusRequest::set_allocated_error_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_message_.IsDefault()) {
          _impl_.error_message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ota.UpdateStatusRequest.error_message)
}

// int32 progress_percentage = 5;
inline void UpdateStatusRequest::clear_progress_percentage() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.progress_percentage_ = 0;
}
inline ::int32_t UpdateStatusRequest::progress_percentage() const {
  // @@protoc_insertion_point(field_get:ota.UpdateStatusRequest.progress_percentage)
  return _internal_progress_percentage();
}
inline void UpdateStatusRequest::set_progress_percentage(::int32_t value) {
  _internal_set_progress_percentage(value);
  // @@protoc_insertion_point(field_set:ota.UpdateStatusRequest.progress_percentage)
}
inline ::int32_t UpdateStatusRequest::_internal_progress_percentage() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.progress_percentage_;
}
inline void UpdateStatusRequest::_internal_set_progress_percentage(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.progress_percentage_ = value;
}

// int64 timestamp = 6;
inline void UpdateStatusRequest::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::int64_t{0};
}
inline ::int64_t UpdateStatusRequest::timestamp() const {
  // @@protoc_insertion_point(field_get:ota.UpdateStatusRequest.timestamp)
  return _internal_timestamp();
}
inline void UpdateStatusRequest::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:ota.UpdateStatusRequest.timestamp)
}
inline ::int64_t UpdateStatusRequest::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void UpdateStatusRequest::_internal_set_timestamp(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// -------------------------------------------------------------------

// UpdateStatusResponse

// bool acknowledged = 1;
inline void UpdateStatusResponse::clear_acknowledged() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.acknowledged_ = false;
}
inline bool UpdateStatusResponse::acknowledged() const {
  // @@protoc_insertion_point(field_get:ota.UpdateStatusResponse.acknowledged)
  return _internal_acknowledged();
}
inline void UpdateStatusResponse::set_acknowledged(bool value) {
  _internal_set_acknowledged(value);
  // @@protoc_insertion_point(field_set:ota.UpdateStatusResponse.acknowledged)
}
inline bool UpdateStatusResponse::_internal_acknowledged() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.acknowledged_;
}
inline void UpdateStatusResponse::_internal_set_acknowledged(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.acknowledged_ = value;
}

// string message = 2;
inline void UpdateStatusResponse::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& UpdateStatusResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ota.UpdateStatusResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateStatusResponse::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ota.UpdateStatusResponse.message)
}
inline std::string* UpdateStatusResponse::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:ota.UpdateStatusResponse.message)
  return _s;
}
inline const std::string& UpdateStatusResponse::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void UpdateStatusResponse::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* UpdateStatusResponse::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* UpdateStatusResponse::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ota.UpdateStatusResponse.message)
  return _impl_.message_.Release();
}
inline void UpdateStatusResponse::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ota.UpdateStatusResponse.message)
}

// int64 timestamp = 3;
inline void UpdateStatusResponse::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::int64_t{0};
}
inline ::int64_t UpdateStatusResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:ota.UpdateStatusResponse.timestamp)
  return _internal_timestamp();
}
inline void UpdateStatusResponse::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:ota.UpdateStatusResponse.timestamp)
}
inline ::int64_t UpdateStatusResponse::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void UpdateStatusResponse::_internal_set_timestamp(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace ota


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::ota::UpdateStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::ota::UpdateStatus>() {
  return ::ota::UpdateStatus_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_ota_5fservice_2eproto_2epb_2eh
