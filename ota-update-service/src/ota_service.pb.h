// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ota_service.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_ota_5fservice_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_ota_5fservice_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_ota_5fservice_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_ota_5fservice_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_ota_5fservice_2eproto;
namespace ota {
class CheckUpdateRequest;
struct CheckUpdateRequestDefaultTypeInternal;
extern CheckUpdateRequestDefaultTypeInternal _CheckUpdateRequest_default_instance_;
class CheckUpdateResponse;
struct CheckUpdateResponseDefaultTypeInternal;
extern CheckUpdateResponseDefaultTypeInternal _CheckUpdateResponse_default_instance_;
class DownloadChunk;
struct DownloadChunkDefaultTypeInternal;
extern DownloadChunkDefaultTypeInternal _DownloadChunk_default_instance_;
class DownloadRequest;
struct DownloadRequestDefaultTypeInternal;
extern DownloadRequestDefaultTypeInternal _DownloadRequest_default_instance_;
class InstallRequest;
struct InstallRequestDefaultTypeInternal;
extern InstallRequestDefaultTypeInternal _InstallRequest_default_instance_;
class InstallResponse;
struct InstallResponseDefaultTypeInternal;
extern InstallResponseDefaultTypeInternal _InstallResponse_default_instance_;
class StatusRequest;
struct StatusRequestDefaultTypeInternal;
extern StatusRequestDefaultTypeInternal _StatusRequest_default_instance_;
class StatusResponse;
struct StatusResponseDefaultTypeInternal;
extern StatusResponseDefaultTypeInternal _StatusResponse_default_instance_;
}  // namespace ota
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace ota {
enum StatusResponse_Status : int {
  StatusResponse_Status_UNKNOWN = 0,
  StatusResponse_Status_DOWNLOADING = 1,
  StatusResponse_Status_VERIFYING = 2,
  StatusResponse_Status_INSTALLING = 3,
  StatusResponse_Status_REBOOTING = 4,
  StatusResponse_Status_COMPLETED = 5,
  StatusResponse_Status_FAILED = 6,
  StatusResponse_Status_ROLLED_BACK = 7,
  StatusResponse_Status_StatusResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  StatusResponse_Status_StatusResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool StatusResponse_Status_IsValid(int value);
extern const uint32_t StatusResponse_Status_internal_data_[];
constexpr StatusResponse_Status StatusResponse_Status_Status_MIN = static_cast<StatusResponse_Status>(0);
constexpr StatusResponse_Status StatusResponse_Status_Status_MAX = static_cast<StatusResponse_Status>(7);
constexpr int StatusResponse_Status_Status_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor*
StatusResponse_Status_descriptor();
template <typename T>
const std::string& StatusResponse_Status_Name(T value) {
  static_assert(std::is_same<T, StatusResponse_Status>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Status_Name().");
  return StatusResponse_Status_Name(static_cast<StatusResponse_Status>(value));
}
template <>
inline const std::string& StatusResponse_Status_Name(StatusResponse_Status value) {
  return ::google::protobuf::internal::NameOfDenseEnum<StatusResponse_Status_descriptor,
                                                 0, 7>(
      static_cast<int>(value));
}
inline bool StatusResponse_Status_Parse(absl::string_view name, StatusResponse_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StatusResponse_Status>(
      StatusResponse_Status_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class StatusResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ota.StatusResponse) */ {
 public:
  inline StatusResponse() : StatusResponse(nullptr) {}
  ~StatusResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StatusResponse(::google::protobuf::internal::ConstantInitialized);

  inline StatusResponse(const StatusResponse& from)
      : StatusResponse(nullptr, from) {}
  StatusResponse(StatusResponse&& from) noexcept
    : StatusResponse() {
    *this = ::std::move(from);
  }

  inline StatusResponse& operator=(const StatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusResponse& operator=(StatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatusResponse* internal_default_instance() {
    return reinterpret_cast<const StatusResponse*>(
               &_StatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(StatusResponse& a, StatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatusResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatusResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StatusResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const StatusResponse& from) {
    StatusResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StatusResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ota.StatusResponse";
  }
  protected:
  explicit StatusResponse(::google::protobuf::Arena* arena);
  StatusResponse(::google::protobuf::Arena* arena, const StatusResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Status = StatusResponse_Status;
  static constexpr Status UNKNOWN = StatusResponse_Status_UNKNOWN;
  static constexpr Status DOWNLOADING = StatusResponse_Status_DOWNLOADING;
  static constexpr Status VERIFYING = StatusResponse_Status_VERIFYING;
  static constexpr Status INSTALLING = StatusResponse_Status_INSTALLING;
  static constexpr Status REBOOTING = StatusResponse_Status_REBOOTING;
  static constexpr Status COMPLETED = StatusResponse_Status_COMPLETED;
  static constexpr Status FAILED = StatusResponse_Status_FAILED;
  static constexpr Status ROLLED_BACK = StatusResponse_Status_ROLLED_BACK;
  static inline bool Status_IsValid(int value) {
    return StatusResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN = StatusResponse_Status_Status_MIN;
  static constexpr Status Status_MAX = StatusResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE = StatusResponse_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Status_descriptor() {
    return StatusResponse_Status_descriptor();
  }
  template <typename T>
  static inline const std::string& Status_Name(T value) {
    return StatusResponse_Status_Name(value);
  }
  static inline bool Status_Parse(absl::string_view name, Status* value) {
    return StatusResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 3,
    kStatusFieldNumber = 1,
    kProgressFieldNumber = 2,
  };
  // string message = 3;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // .ota.StatusResponse.Status status = 1;
  void clear_status() ;
  ::ota::StatusResponse_Status status() const;
  void set_status(::ota::StatusResponse_Status value);

  private:
  ::ota::StatusResponse_Status _internal_status() const;
  void _internal_set_status(::ota::StatusResponse_Status value);

  public:
  // int32 progress = 2;
  void clear_progress() ;
  ::int32_t progress() const;
  void set_progress(::int32_t value);

  private:
  ::int32_t _internal_progress() const;
  void _internal_set_progress(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ota.StatusResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      34, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr message_;
    int status_;
    ::int32_t progress_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ota_5fservice_2eproto;
};// -------------------------------------------------------------------

class StatusRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ota.StatusRequest) */ {
 public:
  inline StatusRequest() : StatusRequest(nullptr) {}
  ~StatusRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StatusRequest(::google::protobuf::internal::ConstantInitialized);

  inline StatusRequest(const StatusRequest& from)
      : StatusRequest(nullptr, from) {}
  StatusRequest(StatusRequest&& from) noexcept
    : StatusRequest() {
    *this = ::std::move(from);
  }

  inline StatusRequest& operator=(const StatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusRequest& operator=(StatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatusRequest* internal_default_instance() {
    return reinterpret_cast<const StatusRequest*>(
               &_StatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(StatusRequest& a, StatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatusRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatusRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StatusRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const StatusRequest& from) {
    StatusRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StatusRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ota.StatusRequest";
  }
  protected:
  explicit StatusRequest(::google::protobuf::Arena* arena);
  StatusRequest(::google::protobuf::Arena* arena, const StatusRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstallationIdFieldNumber = 2,
    kDeviceIdFieldNumber = 1,
  };
  // string installation_id = 2;
  void clear_installation_id() ;
  const std::string& installation_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_installation_id(Arg_&& arg, Args_... args);
  std::string* mutable_installation_id();
  PROTOBUF_NODISCARD std::string* release_installation_id();
  void set_allocated_installation_id(std::string* value);

  private:
  const std::string& _internal_installation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_installation_id(
      const std::string& value);
  std::string* _internal_mutable_installation_id();

  public:
  // int32 device_id = 1;
  void clear_device_id() ;
  ::int32_t device_id() const;
  void set_device_id(::int32_t value);

  private:
  ::int32_t _internal_device_id() const;
  void _internal_set_device_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ota.StatusRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      41, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr installation_id_;
    ::int32_t device_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ota_5fservice_2eproto;
};// -------------------------------------------------------------------

class InstallResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ota.InstallResponse) */ {
 public:
  inline InstallResponse() : InstallResponse(nullptr) {}
  ~InstallResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InstallResponse(::google::protobuf::internal::ConstantInitialized);

  inline InstallResponse(const InstallResponse& from)
      : InstallResponse(nullptr, from) {}
  InstallResponse(InstallResponse&& from) noexcept
    : InstallResponse() {
    *this = ::std::move(from);
  }

  inline InstallResponse& operator=(const InstallResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstallResponse& operator=(InstallResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstallResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const InstallResponse* internal_default_instance() {
    return reinterpret_cast<const InstallResponse*>(
               &_InstallResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(InstallResponse& a, InstallResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(InstallResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstallResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstallResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InstallResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InstallResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const InstallResponse& from) {
    InstallResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InstallResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ota.InstallResponse";
  }
  protected:
  explicit InstallResponse(::google::protobuf::Arena* arena);
  InstallResponse(::google::protobuf::Arena* arena, const InstallResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kInstallationIdFieldNumber = 3,
    kSuccessFieldNumber = 1,
  };
  // string message = 2;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // string installation_id = 3;
  void clear_installation_id() ;
  const std::string& installation_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_installation_id(Arg_&& arg, Args_... args);
  std::string* mutable_installation_id();
  PROTOBUF_NODISCARD std::string* release_installation_id();
  void set_allocated_installation_id(std::string* value);

  private:
  const std::string& _internal_installation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_installation_id(
      const std::string& value);
  std::string* _internal_mutable_installation_id();

  public:
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:ota.InstallResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      50, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::google::protobuf::internal::ArenaStringPtr installation_id_;
    bool success_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ota_5fservice_2eproto;
};// -------------------------------------------------------------------

class InstallRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ota.InstallRequest) */ {
 public:
  inline InstallRequest() : InstallRequest(nullptr) {}
  ~InstallRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InstallRequest(::google::protobuf::internal::ConstantInitialized);

  inline InstallRequest(const InstallRequest& from)
      : InstallRequest(nullptr, from) {}
  InstallRequest(InstallRequest&& from) noexcept
    : InstallRequest() {
    *this = ::std::move(from);
  }

  inline InstallRequest& operator=(const InstallRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstallRequest& operator=(InstallRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstallRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InstallRequest* internal_default_instance() {
    return reinterpret_cast<const InstallRequest*>(
               &_InstallRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(InstallRequest& a, InstallRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InstallRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstallRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstallRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InstallRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InstallRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const InstallRequest& from) {
    InstallRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InstallRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ota.InstallRequest";
  }
  protected:
  explicit InstallRequest(::google::protobuf::Arena* arena);
  InstallRequest(::google::protobuf::Arena* arena, const InstallRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUpdateIdFieldNumber = 2,
    kDeviceIdFieldNumber = 1,
    kAllowRollbackFieldNumber = 3,
  };
  // string update_id = 2;
  void clear_update_id() ;
  const std::string& update_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_update_id(Arg_&& arg, Args_... args);
  std::string* mutable_update_id();
  PROTOBUF_NODISCARD std::string* release_update_id();
  void set_allocated_update_id(std::string* value);

  private:
  const std::string& _internal_update_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_update_id(
      const std::string& value);
  std::string* _internal_mutable_update_id();

  public:
  // int32 device_id = 1;
  void clear_device_id() ;
  ::int32_t device_id() const;
  void set_device_id(::int32_t value);

  private:
  ::int32_t _internal_device_id() const;
  void _internal_set_device_id(::int32_t value);

  public:
  // bool allow_rollback = 3;
  void clear_allow_rollback() ;
  bool allow_rollback() const;
  void set_allow_rollback(bool value);

  private:
  bool _internal_allow_rollback() const;
  void _internal_set_allow_rollback(bool value);

  public:
  // @@protoc_insertion_point(class_scope:ota.InstallRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      36, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr update_id_;
    ::int32_t device_id_;
    bool allow_rollback_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ota_5fservice_2eproto;
};// -------------------------------------------------------------------

class DownloadRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ota.DownloadRequest) */ {
 public:
  inline DownloadRequest() : DownloadRequest(nullptr) {}
  ~DownloadRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DownloadRequest(::google::protobuf::internal::ConstantInitialized);

  inline DownloadRequest(const DownloadRequest& from)
      : DownloadRequest(nullptr, from) {}
  DownloadRequest(DownloadRequest&& from) noexcept
    : DownloadRequest() {
    *this = ::std::move(from);
  }

  inline DownloadRequest& operator=(const DownloadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadRequest& operator=(DownloadRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DownloadRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DownloadRequest* internal_default_instance() {
    return reinterpret_cast<const DownloadRequest*>(
               &_DownloadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DownloadRequest& a, DownloadRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DownloadRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DownloadRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DownloadRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DownloadRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DownloadRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DownloadRequest& from) {
    DownloadRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DownloadRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ota.DownloadRequest";
  }
  protected:
  explicit DownloadRequest(::google::protobuf::Arena* arena);
  DownloadRequest(::google::protobuf::Arena* arena, const DownloadRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUpdateIdFieldNumber = 2,
    kJwtTokenFieldNumber = 3,
    kDeviceIdFieldNumber = 1,
  };
  // string update_id = 2;
  void clear_update_id() ;
  const std::string& update_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_update_id(Arg_&& arg, Args_... args);
  std::string* mutable_update_id();
  PROTOBUF_NODISCARD std::string* release_update_id();
  void set_allocated_update_id(std::string* value);

  private:
  const std::string& _internal_update_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_update_id(
      const std::string& value);
  std::string* _internal_mutable_update_id();

  public:
  // string jwt_token = 3;
  void clear_jwt_token() ;
  const std::string& jwt_token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_jwt_token(Arg_&& arg, Args_... args);
  std::string* mutable_jwt_token();
  PROTOBUF_NODISCARD std::string* release_jwt_token();
  void set_allocated_jwt_token(std::string* value);

  private:
  const std::string& _internal_jwt_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_jwt_token(
      const std::string& value);
  std::string* _internal_mutable_jwt_token();

  public:
  // int32 device_id = 1;
  void clear_device_id() ;
  ::int32_t device_id() const;
  void set_device_id(::int32_t value);

  private:
  ::int32_t _internal_device_id() const;
  void _internal_set_device_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ota.DownloadRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      46, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr update_id_;
    ::google::protobuf::internal::ArenaStringPtr jwt_token_;
    ::int32_t device_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ota_5fservice_2eproto;
};// -------------------------------------------------------------------

class DownloadChunk final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ota.DownloadChunk) */ {
 public:
  inline DownloadChunk() : DownloadChunk(nullptr) {}
  ~DownloadChunk() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DownloadChunk(::google::protobuf::internal::ConstantInitialized);

  inline DownloadChunk(const DownloadChunk& from)
      : DownloadChunk(nullptr, from) {}
  DownloadChunk(DownloadChunk&& from) noexcept
    : DownloadChunk() {
    *this = ::std::move(from);
  }

  inline DownloadChunk& operator=(const DownloadChunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadChunk& operator=(DownloadChunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DownloadChunk& default_instance() {
    return *internal_default_instance();
  }
  static inline const DownloadChunk* internal_default_instance() {
    return reinterpret_cast<const DownloadChunk*>(
               &_DownloadChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DownloadChunk& a, DownloadChunk& b) {
    a.Swap(&b);
  }
  inline void Swap(DownloadChunk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DownloadChunk* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DownloadChunk* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DownloadChunk>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DownloadChunk& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DownloadChunk& from) {
    DownloadChunk::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DownloadChunk* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ota.DownloadChunk";
  }
  protected:
  explicit DownloadChunk(::google::protobuf::Arena* arena);
  DownloadChunk(::google::protobuf::Arena* arena, const DownloadChunk& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kChunkIdFieldNumber = 2,
    kLastChunkFieldNumber = 3,
  };
  // bytes data = 1;
  void clear_data() ;
  const std::string& data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* value);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // int32 chunk_id = 2;
  void clear_chunk_id() ;
  ::int32_t chunk_id() const;
  void set_chunk_id(::int32_t value);

  private:
  ::int32_t _internal_chunk_id() const;
  void _internal_set_chunk_id(::int32_t value);

  public:
  // bool last_chunk = 3;
  void clear_last_chunk() ;
  bool last_chunk() const;
  void set_last_chunk(bool value);

  private:
  bool _internal_last_chunk() const;
  void _internal_set_last_chunk(bool value);

  public:
  // @@protoc_insertion_point(class_scope:ota.DownloadChunk)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr data_;
    ::int32_t chunk_id_;
    bool last_chunk_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ota_5fservice_2eproto;
};// -------------------------------------------------------------------

class CheckUpdateResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ota.CheckUpdateResponse) */ {
 public:
  inline CheckUpdateResponse() : CheckUpdateResponse(nullptr) {}
  ~CheckUpdateResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CheckUpdateResponse(::google::protobuf::internal::ConstantInitialized);

  inline CheckUpdateResponse(const CheckUpdateResponse& from)
      : CheckUpdateResponse(nullptr, from) {}
  CheckUpdateResponse(CheckUpdateResponse&& from) noexcept
    : CheckUpdateResponse() {
    *this = ::std::move(from);
  }

  inline CheckUpdateResponse& operator=(const CheckUpdateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckUpdateResponse& operator=(CheckUpdateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckUpdateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckUpdateResponse* internal_default_instance() {
    return reinterpret_cast<const CheckUpdateResponse*>(
               &_CheckUpdateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CheckUpdateResponse& a, CheckUpdateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckUpdateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckUpdateResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckUpdateResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckUpdateResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CheckUpdateResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CheckUpdateResponse& from) {
    CheckUpdateResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CheckUpdateResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ota.CheckUpdateResponse";
  }
  protected:
  explicit CheckUpdateResponse(::google::protobuf::Arena* arena);
  CheckUpdateResponse(::google::protobuf::Arena* arena, const CheckUpdateResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewVersionFieldNumber = 2,
    kUpdateIdFieldNumber = 4,
    kChangelogFieldNumber = 5,
    kUpdateSizeFieldNumber = 3,
    kUpdateAvailableFieldNumber = 1,
  };
  // string new_version = 2;
  void clear_new_version() ;
  const std::string& new_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_new_version(Arg_&& arg, Args_... args);
  std::string* mutable_new_version();
  PROTOBUF_NODISCARD std::string* release_new_version();
  void set_allocated_new_version(std::string* value);

  private:
  const std::string& _internal_new_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_version(
      const std::string& value);
  std::string* _internal_mutable_new_version();

  public:
  // string update_id = 4;
  void clear_update_id() ;
  const std::string& update_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_update_id(Arg_&& arg, Args_... args);
  std::string* mutable_update_id();
  PROTOBUF_NODISCARD std::string* release_update_id();
  void set_allocated_update_id(std::string* value);

  private:
  const std::string& _internal_update_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_update_id(
      const std::string& value);
  std::string* _internal_mutable_update_id();

  public:
  // string changelog = 5;
  void clear_changelog() ;
  const std::string& changelog() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_changelog(Arg_&& arg, Args_... args);
  std::string* mutable_changelog();
  PROTOBUF_NODISCARD std::string* release_changelog();
  void set_allocated_changelog(std::string* value);

  private:
  const std::string& _internal_changelog() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_changelog(
      const std::string& value);
  std::string* _internal_mutable_changelog();

  public:
  // int64 update_size = 3;
  void clear_update_size() ;
  ::int64_t update_size() const;
  void set_update_size(::int64_t value);

  private:
  ::int64_t _internal_update_size() const;
  void _internal_set_update_size(::int64_t value);

  public:
  // bool update_available = 1;
  void clear_update_available() ;
  bool update_available() const;
  void set_update_available(bool value);

  private:
  bool _internal_update_available() const;
  void _internal_set_update_available(bool value);

  public:
  // @@protoc_insertion_point(class_scope:ota.CheckUpdateResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      61, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr new_version_;
    ::google::protobuf::internal::ArenaStringPtr update_id_;
    ::google::protobuf::internal::ArenaStringPtr changelog_;
    ::int64_t update_size_;
    bool update_available_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ota_5fservice_2eproto;
};// -------------------------------------------------------------------

class CheckUpdateRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ota.CheckUpdateRequest) */ {
 public:
  inline CheckUpdateRequest() : CheckUpdateRequest(nullptr) {}
  ~CheckUpdateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CheckUpdateRequest(::google::protobuf::internal::ConstantInitialized);

  inline CheckUpdateRequest(const CheckUpdateRequest& from)
      : CheckUpdateRequest(nullptr, from) {}
  CheckUpdateRequest(CheckUpdateRequest&& from) noexcept
    : CheckUpdateRequest() {
    *this = ::std::move(from);
  }

  inline CheckUpdateRequest& operator=(const CheckUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckUpdateRequest& operator=(CheckUpdateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckUpdateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const CheckUpdateRequest*>(
               &_CheckUpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CheckUpdateRequest& a, CheckUpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckUpdateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckUpdateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckUpdateRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckUpdateRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CheckUpdateRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CheckUpdateRequest& from) {
    CheckUpdateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CheckUpdateRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ota.CheckUpdateRequest";
  }
  protected:
  explicit CheckUpdateRequest(::google::protobuf::Arena* arena);
  CheckUpdateRequest(::google::protobuf::Arena* arena, const CheckUpdateRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrentVersionFieldNumber = 2,
    kHardwareTypeFieldNumber = 3,
    kDeviceIdFieldNumber = 1,
  };
  // string current_version = 2;
  void clear_current_version() ;
  const std::string& current_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_current_version(Arg_&& arg, Args_... args);
  std::string* mutable_current_version();
  PROTOBUF_NODISCARD std::string* release_current_version();
  void set_allocated_current_version(std::string* value);

  private:
  const std::string& _internal_current_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_current_version(
      const std::string& value);
  std::string* _internal_mutable_current_version();

  public:
  // string hardware_type = 3;
  void clear_hardware_type() ;
  const std::string& hardware_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hardware_type(Arg_&& arg, Args_... args);
  std::string* mutable_hardware_type();
  PROTOBUF_NODISCARD std::string* release_hardware_type();
  void set_allocated_hardware_type(std::string* value);

  private:
  const std::string& _internal_hardware_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hardware_type(
      const std::string& value);
  std::string* _internal_mutable_hardware_type();

  public:
  // int32 device_id = 1;
  void clear_device_id() ;
  ::int32_t device_id() const;
  void set_device_id(::int32_t value);

  private:
  ::int32_t _internal_device_id() const;
  void _internal_set_device_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ota.CheckUpdateRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      59, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr current_version_;
    ::google::protobuf::internal::ArenaStringPtr hardware_type_;
    ::int32_t device_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ota_5fservice_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// CheckUpdateRequest

// int32 device_id = 1;
inline void CheckUpdateRequest::clear_device_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_id_ = 0;
}
inline ::int32_t CheckUpdateRequest::device_id() const {
  // @@protoc_insertion_point(field_get:ota.CheckUpdateRequest.device_id)
  return _internal_device_id();
}
inline void CheckUpdateRequest::set_device_id(::int32_t value) {
  _internal_set_device_id(value);
  // @@protoc_insertion_point(field_set:ota.CheckUpdateRequest.device_id)
}
inline ::int32_t CheckUpdateRequest::_internal_device_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.device_id_;
}
inline void CheckUpdateRequest::_internal_set_device_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_id_ = value;
}

// string current_version = 2;
inline void CheckUpdateRequest::clear_current_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.current_version_.ClearToEmpty();
}
inline const std::string& CheckUpdateRequest::current_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ota.CheckUpdateRequest.current_version)
  return _internal_current_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CheckUpdateRequest::set_current_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.current_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ota.CheckUpdateRequest.current_version)
}
inline std::string* CheckUpdateRequest::mutable_current_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_current_version();
  // @@protoc_insertion_point(field_mutable:ota.CheckUpdateRequest.current_version)
  return _s;
}
inline const std::string& CheckUpdateRequest::_internal_current_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.current_version_.Get();
}
inline void CheckUpdateRequest::_internal_set_current_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.current_version_.Set(value, GetArena());
}
inline std::string* CheckUpdateRequest::_internal_mutable_current_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.current_version_.Mutable( GetArena());
}
inline std::string* CheckUpdateRequest::release_current_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ota.CheckUpdateRequest.current_version)
  return _impl_.current_version_.Release();
}
inline void CheckUpdateRequest::set_allocated_current_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.current_version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.current_version_.IsDefault()) {
          _impl_.current_version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ota.CheckUpdateRequest.current_version)
}

// string hardware_type = 3;
inline void CheckUpdateRequest::clear_hardware_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hardware_type_.ClearToEmpty();
}
inline const std::string& CheckUpdateRequest::hardware_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ota.CheckUpdateRequest.hardware_type)
  return _internal_hardware_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CheckUpdateRequest::set_hardware_type(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.hardware_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ota.CheckUpdateRequest.hardware_type)
}
inline std::string* CheckUpdateRequest::mutable_hardware_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_hardware_type();
  // @@protoc_insertion_point(field_mutable:ota.CheckUpdateRequest.hardware_type)
  return _s;
}
inline const std::string& CheckUpdateRequest::_internal_hardware_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hardware_type_.Get();
}
inline void CheckUpdateRequest::_internal_set_hardware_type(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.hardware_type_.Set(value, GetArena());
}
inline std::string* CheckUpdateRequest::_internal_mutable_hardware_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.hardware_type_.Mutable( GetArena());
}
inline std::string* CheckUpdateRequest::release_hardware_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ota.CheckUpdateRequest.hardware_type)
  return _impl_.hardware_type_.Release();
}
inline void CheckUpdateRequest::set_allocated_hardware_type(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hardware_type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.hardware_type_.IsDefault()) {
          _impl_.hardware_type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ota.CheckUpdateRequest.hardware_type)
}

// -------------------------------------------------------------------

// CheckUpdateResponse

// bool update_available = 1;
inline void CheckUpdateResponse::clear_update_available() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.update_available_ = false;
}
inline bool CheckUpdateResponse::update_available() const {
  // @@protoc_insertion_point(field_get:ota.CheckUpdateResponse.update_available)
  return _internal_update_available();
}
inline void CheckUpdateResponse::set_update_available(bool value) {
  _internal_set_update_available(value);
  // @@protoc_insertion_point(field_set:ota.CheckUpdateResponse.update_available)
}
inline bool CheckUpdateResponse::_internal_update_available() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.update_available_;
}
inline void CheckUpdateResponse::_internal_set_update_available(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.update_available_ = value;
}

// string new_version = 2;
inline void CheckUpdateResponse::clear_new_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.new_version_.ClearToEmpty();
}
inline const std::string& CheckUpdateResponse::new_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ota.CheckUpdateResponse.new_version)
  return _internal_new_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CheckUpdateResponse::set_new_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.new_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ota.CheckUpdateResponse.new_version)
}
inline std::string* CheckUpdateResponse::mutable_new_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_new_version();
  // @@protoc_insertion_point(field_mutable:ota.CheckUpdateResponse.new_version)
  return _s;
}
inline const std::string& CheckUpdateResponse::_internal_new_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.new_version_.Get();
}
inline void CheckUpdateResponse::_internal_set_new_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.new_version_.Set(value, GetArena());
}
inline std::string* CheckUpdateResponse::_internal_mutable_new_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.new_version_.Mutable( GetArena());
}
inline std::string* CheckUpdateResponse::release_new_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ota.CheckUpdateResponse.new_version)
  return _impl_.new_version_.Release();
}
inline void CheckUpdateResponse::set_allocated_new_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.new_version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.new_version_.IsDefault()) {
          _impl_.new_version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ota.CheckUpdateResponse.new_version)
}

// int64 update_size = 3;
inline void CheckUpdateResponse::clear_update_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.update_size_ = ::int64_t{0};
}
inline ::int64_t CheckUpdateResponse::update_size() const {
  // @@protoc_insertion_point(field_get:ota.CheckUpdateResponse.update_size)
  return _internal_update_size();
}
inline void CheckUpdateResponse::set_update_size(::int64_t value) {
  _internal_set_update_size(value);
  // @@protoc_insertion_point(field_set:ota.CheckUpdateResponse.update_size)
}
inline ::int64_t CheckUpdateResponse::_internal_update_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.update_size_;
}
inline void CheckUpdateResponse::_internal_set_update_size(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.update_size_ = value;
}

// string update_id = 4;
inline void CheckUpdateResponse::clear_update_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.update_id_.ClearToEmpty();
}
inline const std::string& CheckUpdateResponse::update_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ota.CheckUpdateResponse.update_id)
  return _internal_update_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CheckUpdateResponse::set_update_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.update_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ota.CheckUpdateResponse.update_id)
}
inline std::string* CheckUpdateResponse::mutable_update_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_update_id();
  // @@protoc_insertion_point(field_mutable:ota.CheckUpdateResponse.update_id)
  return _s;
}
inline const std::string& CheckUpdateResponse::_internal_update_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.update_id_.Get();
}
inline void CheckUpdateResponse::_internal_set_update_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.update_id_.Set(value, GetArena());
}
inline std::string* CheckUpdateResponse::_internal_mutable_update_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.update_id_.Mutable( GetArena());
}
inline std::string* CheckUpdateResponse::release_update_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ota.CheckUpdateResponse.update_id)
  return _impl_.update_id_.Release();
}
inline void CheckUpdateResponse::set_allocated_update_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.update_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.update_id_.IsDefault()) {
          _impl_.update_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ota.CheckUpdateResponse.update_id)
}

// string changelog = 5;
inline void CheckUpdateResponse::clear_changelog() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.changelog_.ClearToEmpty();
}
inline const std::string& CheckUpdateResponse::changelog() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ota.CheckUpdateResponse.changelog)
  return _internal_changelog();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CheckUpdateResponse::set_changelog(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.changelog_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ota.CheckUpdateResponse.changelog)
}
inline std::string* CheckUpdateResponse::mutable_changelog() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_changelog();
  // @@protoc_insertion_point(field_mutable:ota.CheckUpdateResponse.changelog)
  return _s;
}
inline const std::string& CheckUpdateResponse::_internal_changelog() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.changelog_.Get();
}
inline void CheckUpdateResponse::_internal_set_changelog(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.changelog_.Set(value, GetArena());
}
inline std::string* CheckUpdateResponse::_internal_mutable_changelog() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.changelog_.Mutable( GetArena());
}
inline std::string* CheckUpdateResponse::release_changelog() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ota.CheckUpdateResponse.changelog)
  return _impl_.changelog_.Release();
}
inline void CheckUpdateResponse::set_allocated_changelog(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.changelog_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.changelog_.IsDefault()) {
          _impl_.changelog_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ota.CheckUpdateResponse.changelog)
}

// -------------------------------------------------------------------

// DownloadRequest

// int32 device_id = 1;
inline void DownloadRequest::clear_device_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_id_ = 0;
}
inline ::int32_t DownloadRequest::device_id() const {
  // @@protoc_insertion_point(field_get:ota.DownloadRequest.device_id)
  return _internal_device_id();
}
inline void DownloadRequest::set_device_id(::int32_t value) {
  _internal_set_device_id(value);
  // @@protoc_insertion_point(field_set:ota.DownloadRequest.device_id)
}
inline ::int32_t DownloadRequest::_internal_device_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.device_id_;
}
inline void DownloadRequest::_internal_set_device_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_id_ = value;
}

// string update_id = 2;
inline void DownloadRequest::clear_update_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.update_id_.ClearToEmpty();
}
inline const std::string& DownloadRequest::update_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ota.DownloadRequest.update_id)
  return _internal_update_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DownloadRequest::set_update_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.update_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ota.DownloadRequest.update_id)
}
inline std::string* DownloadRequest::mutable_update_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_update_id();
  // @@protoc_insertion_point(field_mutable:ota.DownloadRequest.update_id)
  return _s;
}
inline const std::string& DownloadRequest::_internal_update_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.update_id_.Get();
}
inline void DownloadRequest::_internal_set_update_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.update_id_.Set(value, GetArena());
}
inline std::string* DownloadRequest::_internal_mutable_update_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.update_id_.Mutable( GetArena());
}
inline std::string* DownloadRequest::release_update_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ota.DownloadRequest.update_id)
  return _impl_.update_id_.Release();
}
inline void DownloadRequest::set_allocated_update_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.update_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.update_id_.IsDefault()) {
          _impl_.update_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ota.DownloadRequest.update_id)
}

// string jwt_token = 3;
inline void DownloadRequest::clear_jwt_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.jwt_token_.ClearToEmpty();
}
inline const std::string& DownloadRequest::jwt_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ota.DownloadRequest.jwt_token)
  return _internal_jwt_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DownloadRequest::set_jwt_token(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.jwt_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ota.DownloadRequest.jwt_token)
}
inline std::string* DownloadRequest::mutable_jwt_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_jwt_token();
  // @@protoc_insertion_point(field_mutable:ota.DownloadRequest.jwt_token)
  return _s;
}
inline const std::string& DownloadRequest::_internal_jwt_token() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.jwt_token_.Get();
}
inline void DownloadRequest::_internal_set_jwt_token(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.jwt_token_.Set(value, GetArena());
}
inline std::string* DownloadRequest::_internal_mutable_jwt_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.jwt_token_.Mutable( GetArena());
}
inline std::string* DownloadRequest::release_jwt_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ota.DownloadRequest.jwt_token)
  return _impl_.jwt_token_.Release();
}
inline void DownloadRequest::set_allocated_jwt_token(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.jwt_token_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.jwt_token_.IsDefault()) {
          _impl_.jwt_token_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ota.DownloadRequest.jwt_token)
}

// -------------------------------------------------------------------

// DownloadChunk

// bytes data = 1;
inline void DownloadChunk::clear_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.ClearToEmpty();
}
inline const std::string& DownloadChunk::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ota.DownloadChunk.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DownloadChunk::set_data(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ota.DownloadChunk.data)
}
inline std::string* DownloadChunk::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:ota.DownloadChunk.data)
  return _s;
}
inline const std::string& DownloadChunk::_internal_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_.Get();
}
inline void DownloadChunk::_internal_set_data(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.data_.Set(value, GetArena());
}
inline std::string* DownloadChunk::_internal_mutable_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.data_.Mutable( GetArena());
}
inline std::string* DownloadChunk::release_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ota.DownloadChunk.data)
  return _impl_.data_.Release();
}
inline void DownloadChunk::set_allocated_data(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_.IsDefault()) {
          _impl_.data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ota.DownloadChunk.data)
}

// int32 chunk_id = 2;
inline void DownloadChunk::clear_chunk_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.chunk_id_ = 0;
}
inline ::int32_t DownloadChunk::chunk_id() const {
  // @@protoc_insertion_point(field_get:ota.DownloadChunk.chunk_id)
  return _internal_chunk_id();
}
inline void DownloadChunk::set_chunk_id(::int32_t value) {
  _internal_set_chunk_id(value);
  // @@protoc_insertion_point(field_set:ota.DownloadChunk.chunk_id)
}
inline ::int32_t DownloadChunk::_internal_chunk_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.chunk_id_;
}
inline void DownloadChunk::_internal_set_chunk_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.chunk_id_ = value;
}

// bool last_chunk = 3;
inline void DownloadChunk::clear_last_chunk() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.last_chunk_ = false;
}
inline bool DownloadChunk::last_chunk() const {
  // @@protoc_insertion_point(field_get:ota.DownloadChunk.last_chunk)
  return _internal_last_chunk();
}
inline void DownloadChunk::set_last_chunk(bool value) {
  _internal_set_last_chunk(value);
  // @@protoc_insertion_point(field_set:ota.DownloadChunk.last_chunk)
}
inline bool DownloadChunk::_internal_last_chunk() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.last_chunk_;
}
inline void DownloadChunk::_internal_set_last_chunk(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.last_chunk_ = value;
}

// -------------------------------------------------------------------

// InstallRequest

// int32 device_id = 1;
inline void InstallRequest::clear_device_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_id_ = 0;
}
inline ::int32_t InstallRequest::device_id() const {
  // @@protoc_insertion_point(field_get:ota.InstallRequest.device_id)
  return _internal_device_id();
}
inline void InstallRequest::set_device_id(::int32_t value) {
  _internal_set_device_id(value);
  // @@protoc_insertion_point(field_set:ota.InstallRequest.device_id)
}
inline ::int32_t InstallRequest::_internal_device_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.device_id_;
}
inline void InstallRequest::_internal_set_device_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_id_ = value;
}

// string update_id = 2;
inline void InstallRequest::clear_update_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.update_id_.ClearToEmpty();
}
inline const std::string& InstallRequest::update_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ota.InstallRequest.update_id)
  return _internal_update_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InstallRequest::set_update_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.update_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ota.InstallRequest.update_id)
}
inline std::string* InstallRequest::mutable_update_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_update_id();
  // @@protoc_insertion_point(field_mutable:ota.InstallRequest.update_id)
  return _s;
}
inline const std::string& InstallRequest::_internal_update_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.update_id_.Get();
}
inline void InstallRequest::_internal_set_update_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.update_id_.Set(value, GetArena());
}
inline std::string* InstallRequest::_internal_mutable_update_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.update_id_.Mutable( GetArena());
}
inline std::string* InstallRequest::release_update_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ota.InstallRequest.update_id)
  return _impl_.update_id_.Release();
}
inline void InstallRequest::set_allocated_update_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.update_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.update_id_.IsDefault()) {
          _impl_.update_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ota.InstallRequest.update_id)
}

// bool allow_rollback = 3;
inline void InstallRequest::clear_allow_rollback() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.allow_rollback_ = false;
}
inline bool InstallRequest::allow_rollback() const {
  // @@protoc_insertion_point(field_get:ota.InstallRequest.allow_rollback)
  return _internal_allow_rollback();
}
inline void InstallRequest::set_allow_rollback(bool value) {
  _internal_set_allow_rollback(value);
  // @@protoc_insertion_point(field_set:ota.InstallRequest.allow_rollback)
}
inline bool InstallRequest::_internal_allow_rollback() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.allow_rollback_;
}
inline void InstallRequest::_internal_set_allow_rollback(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.allow_rollback_ = value;
}

// -------------------------------------------------------------------

// InstallResponse

// bool success = 1;
inline void InstallResponse::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool InstallResponse::success() const {
  // @@protoc_insertion_point(field_get:ota.InstallResponse.success)
  return _internal_success();
}
inline void InstallResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:ota.InstallResponse.success)
}
inline bool InstallResponse::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void InstallResponse::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.success_ = value;
}

// string message = 2;
inline void InstallResponse::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& InstallResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ota.InstallResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InstallResponse::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ota.InstallResponse.message)
}
inline std::string* InstallResponse::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:ota.InstallResponse.message)
  return _s;
}
inline const std::string& InstallResponse::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void InstallResponse::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* InstallResponse::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* InstallResponse::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ota.InstallResponse.message)
  return _impl_.message_.Release();
}
inline void InstallResponse::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ota.InstallResponse.message)
}

// string installation_id = 3;
inline void InstallResponse::clear_installation_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.installation_id_.ClearToEmpty();
}
inline const std::string& InstallResponse::installation_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ota.InstallResponse.installation_id)
  return _internal_installation_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InstallResponse::set_installation_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.installation_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ota.InstallResponse.installation_id)
}
inline std::string* InstallResponse::mutable_installation_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_installation_id();
  // @@protoc_insertion_point(field_mutable:ota.InstallResponse.installation_id)
  return _s;
}
inline const std::string& InstallResponse::_internal_installation_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.installation_id_.Get();
}
inline void InstallResponse::_internal_set_installation_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.installation_id_.Set(value, GetArena());
}
inline std::string* InstallResponse::_internal_mutable_installation_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.installation_id_.Mutable( GetArena());
}
inline std::string* InstallResponse::release_installation_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ota.InstallResponse.installation_id)
  return _impl_.installation_id_.Release();
}
inline void InstallResponse::set_allocated_installation_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.installation_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.installation_id_.IsDefault()) {
          _impl_.installation_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ota.InstallResponse.installation_id)
}

// -------------------------------------------------------------------

// StatusRequest

// int32 device_id = 1;
inline void StatusRequest::clear_device_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_id_ = 0;
}
inline ::int32_t StatusRequest::device_id() const {
  // @@protoc_insertion_point(field_get:ota.StatusRequest.device_id)
  return _internal_device_id();
}
inline void StatusRequest::set_device_id(::int32_t value) {
  _internal_set_device_id(value);
  // @@protoc_insertion_point(field_set:ota.StatusRequest.device_id)
}
inline ::int32_t StatusRequest::_internal_device_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.device_id_;
}
inline void StatusRequest::_internal_set_device_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_id_ = value;
}

// string installation_id = 2;
inline void StatusRequest::clear_installation_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.installation_id_.ClearToEmpty();
}
inline const std::string& StatusRequest::installation_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ota.StatusRequest.installation_id)
  return _internal_installation_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StatusRequest::set_installation_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.installation_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ota.StatusRequest.installation_id)
}
inline std::string* StatusRequest::mutable_installation_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_installation_id();
  // @@protoc_insertion_point(field_mutable:ota.StatusRequest.installation_id)
  return _s;
}
inline const std::string& StatusRequest::_internal_installation_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.installation_id_.Get();
}
inline void StatusRequest::_internal_set_installation_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.installation_id_.Set(value, GetArena());
}
inline std::string* StatusRequest::_internal_mutable_installation_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.installation_id_.Mutable( GetArena());
}
inline std::string* StatusRequest::release_installation_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ota.StatusRequest.installation_id)
  return _impl_.installation_id_.Release();
}
inline void StatusRequest::set_allocated_installation_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.installation_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.installation_id_.IsDefault()) {
          _impl_.installation_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ota.StatusRequest.installation_id)
}

// -------------------------------------------------------------------

// StatusResponse

// .ota.StatusResponse.Status status = 1;
inline void StatusResponse::clear_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_ = 0;
}
inline ::ota::StatusResponse_Status StatusResponse::status() const {
  // @@protoc_insertion_point(field_get:ota.StatusResponse.status)
  return _internal_status();
}
inline void StatusResponse::set_status(::ota::StatusResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:ota.StatusResponse.status)
}
inline ::ota::StatusResponse_Status StatusResponse::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::ota::StatusResponse_Status>(_impl_.status_);
}
inline void StatusResponse::_internal_set_status(::ota::StatusResponse_Status value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.status_ = value;
}

// int32 progress = 2;
inline void StatusResponse::clear_progress() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.progress_ = 0;
}
inline ::int32_t StatusResponse::progress() const {
  // @@protoc_insertion_point(field_get:ota.StatusResponse.progress)
  return _internal_progress();
}
inline void StatusResponse::set_progress(::int32_t value) {
  _internal_set_progress(value);
  // @@protoc_insertion_point(field_set:ota.StatusResponse.progress)
}
inline ::int32_t StatusResponse::_internal_progress() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.progress_;
}
inline void StatusResponse::_internal_set_progress(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.progress_ = value;
}

// string message = 3;
inline void StatusResponse::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& StatusResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ota.StatusResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StatusResponse::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ota.StatusResponse.message)
}
inline std::string* StatusResponse::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:ota.StatusResponse.message)
  return _s;
}
inline const std::string& StatusResponse::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void StatusResponse::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* StatusResponse::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* StatusResponse::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ota.StatusResponse.message)
  return _impl_.message_.Release();
}
inline void StatusResponse::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ota.StatusResponse.message)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace ota


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::ota::StatusResponse_Status> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::ota::StatusResponse_Status>() {
  return ::ota::StatusResponse_Status_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_ota_5fservice_2eproto_2epb_2eh
