// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ota_service.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_ota_5fservice_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_ota_5fservice_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_ota_5fservice_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_ota_5fservice_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_ota_5fservice_2eproto;
namespace ota {
class CheckUpdatesRequest;
struct CheckUpdatesRequestDefaultTypeInternal;
extern CheckUpdatesRequestDefaultTypeInternal _CheckUpdatesRequest_default_instance_;
class CheckUpdatesResponse;
struct CheckUpdatesResponseDefaultTypeInternal;
extern CheckUpdatesResponseDefaultTypeInternal _CheckUpdatesResponse_default_instance_;
class DownloadRequest;
struct DownloadRequestDefaultTypeInternal;
extern DownloadRequestDefaultTypeInternal _DownloadRequest_default_instance_;
class DownloadResponse;
struct DownloadResponseDefaultTypeInternal;
extern DownloadResponseDefaultTypeInternal _DownloadResponse_default_instance_;
class StatusReport;
struct StatusReportDefaultTypeInternal;
extern StatusReportDefaultTypeInternal _StatusReport_default_instance_;
class StatusResponse;
struct StatusResponseDefaultTypeInternal;
extern StatusResponseDefaultTypeInternal _StatusResponse_default_instance_;
class UpdateInfo;
struct UpdateInfoDefaultTypeInternal;
extern UpdateInfoDefaultTypeInternal _UpdateInfo_default_instance_;
}  // namespace ota
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace ota {

// ===================================================================


// -------------------------------------------------------------------

class UpdateInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ota.UpdateInfo) */ {
 public:
  inline UpdateInfo() : UpdateInfo(nullptr) {}
  ~UpdateInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateInfo(::google::protobuf::internal::ConstantInitialized);

  inline UpdateInfo(const UpdateInfo& from)
      : UpdateInfo(nullptr, from) {}
  UpdateInfo(UpdateInfo&& from) noexcept
    : UpdateInfo() {
    *this = ::std::move(from);
  }

  inline UpdateInfo& operator=(const UpdateInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateInfo& operator=(UpdateInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateInfo* internal_default_instance() {
    return reinterpret_cast<const UpdateInfo*>(
               &_UpdateInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(UpdateInfo& a, UpdateInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateInfo& from) {
    UpdateInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ota.UpdateInfo";
  }
  protected:
  explicit UpdateInfo(::google::protobuf::Arena* arena);
  UpdateInfo(::google::protobuf::Arena* arena, const UpdateInfo& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppNameFieldNumber = 1,
    kVersionFieldNumber = 2,
    kChecksumFieldNumber = 3,
    kTargetPathFieldNumber = 4,
  };
  // string app_name = 1;
  void clear_app_name() ;
  const std::string& app_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_app_name(Arg_&& arg, Args_... args);
  std::string* mutable_app_name();
  PROTOBUF_NODISCARD std::string* release_app_name();
  void set_allocated_app_name(std::string* value);

  private:
  const std::string& _internal_app_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_name(
      const std::string& value);
  std::string* _internal_mutable_app_name();

  public:
  // string version = 2;
  void clear_version() ;
  const std::string& version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_version(Arg_&& arg, Args_... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* value);

  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(
      const std::string& value);
  std::string* _internal_mutable_version();

  public:
  // string checksum = 3;
  void clear_checksum() ;
  const std::string& checksum() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_checksum(Arg_&& arg, Args_... args);
  std::string* mutable_checksum();
  PROTOBUF_NODISCARD std::string* release_checksum();
  void set_allocated_checksum(std::string* value);

  private:
  const std::string& _internal_checksum() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_checksum(
      const std::string& value);
  std::string* _internal_mutable_checksum();

  public:
  // string target_path = 4;
  void clear_target_path() ;
  const std::string& target_path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target_path(Arg_&& arg, Args_... args);
  std::string* mutable_target_path();
  PROTOBUF_NODISCARD std::string* release_target_path();
  void set_allocated_target_path(std::string* value);

  private:
  const std::string& _internal_target_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_path(
      const std::string& value);
  std::string* _internal_mutable_target_path();

  public:
  // @@protoc_insertion_point(class_scope:ota.UpdateInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      57, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr app_name_;
    ::google::protobuf::internal::ArenaStringPtr version_;
    ::google::protobuf::internal::ArenaStringPtr checksum_;
    ::google::protobuf::internal::ArenaStringPtr target_path_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ota_5fservice_2eproto;
};// -------------------------------------------------------------------

class StatusResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ota.StatusResponse) */ {
 public:
  inline StatusResponse() : StatusResponse(nullptr) {}
  ~StatusResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StatusResponse(::google::protobuf::internal::ConstantInitialized);

  inline StatusResponse(const StatusResponse& from)
      : StatusResponse(nullptr, from) {}
  StatusResponse(StatusResponse&& from) noexcept
    : StatusResponse() {
    *this = ::std::move(from);
  }

  inline StatusResponse& operator=(const StatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusResponse& operator=(StatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatusResponse* internal_default_instance() {
    return reinterpret_cast<const StatusResponse*>(
               &_StatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(StatusResponse& a, StatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatusResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatusResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StatusResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const StatusResponse& from) {
    StatusResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StatusResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ota.StatusResponse";
  }
  protected:
  explicit StatusResponse(::google::protobuf::Arena* arena);
  StatusResponse(::google::protobuf::Arena* arena, const StatusResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string message = 2;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:ota.StatusResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      34, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr message_;
    bool success_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ota_5fservice_2eproto;
};// -------------------------------------------------------------------

class StatusReport final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ota.StatusReport) */ {
 public:
  inline StatusReport() : StatusReport(nullptr) {}
  ~StatusReport() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StatusReport(::google::protobuf::internal::ConstantInitialized);

  inline StatusReport(const StatusReport& from)
      : StatusReport(nullptr, from) {}
  StatusReport(StatusReport&& from) noexcept
    : StatusReport() {
    *this = ::std::move(from);
  }

  inline StatusReport& operator=(const StatusReport& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusReport& operator=(StatusReport&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatusReport& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatusReport* internal_default_instance() {
    return reinterpret_cast<const StatusReport*>(
               &_StatusReport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(StatusReport& a, StatusReport& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusReport* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusReport* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatusReport* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatusReport>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StatusReport& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const StatusReport& from) {
    StatusReport::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StatusReport* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ota.StatusReport";
  }
  protected:
  explicit StatusReport(::google::protobuf::Arena* arena);
  StatusReport(::google::protobuf::Arena* arena, const StatusReport& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppNameFieldNumber = 2,
    kStatusFieldNumber = 3,
    kErrorMessageFieldNumber = 4,
    kVersionFieldNumber = 5,
    kDeviceIdFieldNumber = 1,
  };
  // string app_name = 2;
  void clear_app_name() ;
  const std::string& app_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_app_name(Arg_&& arg, Args_... args);
  std::string* mutable_app_name();
  PROTOBUF_NODISCARD std::string* release_app_name();
  void set_allocated_app_name(std::string* value);

  private:
  const std::string& _internal_app_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_name(
      const std::string& value);
  std::string* _internal_mutable_app_name();

  public:
  // string status = 3;
  void clear_status() ;
  const std::string& status() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_status(Arg_&& arg, Args_... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* value);

  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(
      const std::string& value);
  std::string* _internal_mutable_status();

  public:
  // string error_message = 4;
  void clear_error_message() ;
  const std::string& error_message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_message(Arg_&& arg, Args_... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* value);

  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(
      const std::string& value);
  std::string* _internal_mutable_error_message();

  public:
  // string version = 5;
  void clear_version() ;
  const std::string& version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_version(Arg_&& arg, Args_... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* value);

  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(
      const std::string& value);
  std::string* _internal_mutable_version();

  public:
  // int32 device_id = 1;
  void clear_device_id() ;
  ::int32_t device_id() const;
  void set_device_id(::int32_t value);

  private:
  ::int32_t _internal_device_id() const;
  void _internal_set_device_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ota.StatusReport)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      59, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr app_name_;
    ::google::protobuf::internal::ArenaStringPtr status_;
    ::google::protobuf::internal::ArenaStringPtr error_message_;
    ::google::protobuf::internal::ArenaStringPtr version_;
    ::int32_t device_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ota_5fservice_2eproto;
};// -------------------------------------------------------------------

class DownloadResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ota.DownloadResponse) */ {
 public:
  inline DownloadResponse() : DownloadResponse(nullptr) {}
  ~DownloadResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DownloadResponse(::google::protobuf::internal::ConstantInitialized);

  inline DownloadResponse(const DownloadResponse& from)
      : DownloadResponse(nullptr, from) {}
  DownloadResponse(DownloadResponse&& from) noexcept
    : DownloadResponse() {
    *this = ::std::move(from);
  }

  inline DownloadResponse& operator=(const DownloadResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadResponse& operator=(DownloadResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DownloadResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DownloadResponse* internal_default_instance() {
    return reinterpret_cast<const DownloadResponse*>(
               &_DownloadResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DownloadResponse& a, DownloadResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DownloadResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DownloadResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DownloadResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DownloadResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DownloadResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DownloadResponse& from) {
    DownloadResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DownloadResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ota.DownloadResponse";
  }
  protected:
  explicit DownloadResponse(::google::protobuf::Arena* arena);
  DownloadResponse(::google::protobuf::Arena* arena, const DownloadResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kTotalSizeFieldNumber = 2,
    kCurrentSizeFieldNumber = 3,
  };
  // bytes data = 1;
  void clear_data() ;
  const std::string& data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* value);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // int64 total_size = 2;
  void clear_total_size() ;
  ::int64_t total_size() const;
  void set_total_size(::int64_t value);

  private:
  ::int64_t _internal_total_size() const;
  void _internal_set_total_size(::int64_t value);

  public:
  // int64 current_size = 3;
  void clear_current_size() ;
  ::int64_t current_size() const;
  void set_current_size(::int64_t value);

  private:
  ::int64_t _internal_current_size() const;
  void _internal_set_current_size(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:ota.DownloadResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr data_;
    ::int64_t total_size_;
    ::int64_t current_size_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ota_5fservice_2eproto;
};// -------------------------------------------------------------------

class DownloadRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ota.DownloadRequest) */ {
 public:
  inline DownloadRequest() : DownloadRequest(nullptr) {}
  ~DownloadRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DownloadRequest(::google::protobuf::internal::ConstantInitialized);

  inline DownloadRequest(const DownloadRequest& from)
      : DownloadRequest(nullptr, from) {}
  DownloadRequest(DownloadRequest&& from) noexcept
    : DownloadRequest() {
    *this = ::std::move(from);
  }

  inline DownloadRequest& operator=(const DownloadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadRequest& operator=(DownloadRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DownloadRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DownloadRequest* internal_default_instance() {
    return reinterpret_cast<const DownloadRequest*>(
               &_DownloadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DownloadRequest& a, DownloadRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DownloadRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DownloadRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DownloadRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DownloadRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DownloadRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DownloadRequest& from) {
    DownloadRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DownloadRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ota.DownloadRequest";
  }
  protected:
  explicit DownloadRequest(::google::protobuf::Arena* arena);
  DownloadRequest(::google::protobuf::Arena* arena, const DownloadRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppNameFieldNumber = 2,
    kDeviceIdFieldNumber = 1,
  };
  // string app_name = 2;
  void clear_app_name() ;
  const std::string& app_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_app_name(Arg_&& arg, Args_... args);
  std::string* mutable_app_name();
  PROTOBUF_NODISCARD std::string* release_app_name();
  void set_allocated_app_name(std::string* value);

  private:
  const std::string& _internal_app_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_name(
      const std::string& value);
  std::string* _internal_mutable_app_name();

  public:
  // int32 device_id = 1;
  void clear_device_id() ;
  ::int32_t device_id() const;
  void set_device_id(::int32_t value);

  private:
  ::int32_t _internal_device_id() const;
  void _internal_set_device_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ota.DownloadRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      36, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr app_name_;
    ::int32_t device_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ota_5fservice_2eproto;
};// -------------------------------------------------------------------

class CheckUpdatesRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ota.CheckUpdatesRequest) */ {
 public:
  inline CheckUpdatesRequest() : CheckUpdatesRequest(nullptr) {}
  ~CheckUpdatesRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CheckUpdatesRequest(::google::protobuf::internal::ConstantInitialized);

  inline CheckUpdatesRequest(const CheckUpdatesRequest& from)
      : CheckUpdatesRequest(nullptr, from) {}
  CheckUpdatesRequest(CheckUpdatesRequest&& from) noexcept
    : CheckUpdatesRequest() {
    *this = ::std::move(from);
  }

  inline CheckUpdatesRequest& operator=(const CheckUpdatesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckUpdatesRequest& operator=(CheckUpdatesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckUpdatesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckUpdatesRequest* internal_default_instance() {
    return reinterpret_cast<const CheckUpdatesRequest*>(
               &_CheckUpdatesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CheckUpdatesRequest& a, CheckUpdatesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckUpdatesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckUpdatesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckUpdatesRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckUpdatesRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CheckUpdatesRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CheckUpdatesRequest& from) {
    CheckUpdatesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CheckUpdatesRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ota.CheckUpdatesRequest";
  }
  protected:
  explicit CheckUpdatesRequest(::google::protobuf::Arena* arena);
  CheckUpdatesRequest(::google::protobuf::Arena* arena, const CheckUpdatesRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppNameFieldNumber = 2,
    kCurrentVersionFieldNumber = 3,
    kDeviceIdFieldNumber = 1,
  };
  // string app_name = 2;
  void clear_app_name() ;
  const std::string& app_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_app_name(Arg_&& arg, Args_... args);
  std::string* mutable_app_name();
  PROTOBUF_NODISCARD std::string* release_app_name();
  void set_allocated_app_name(std::string* value);

  private:
  const std::string& _internal_app_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_name(
      const std::string& value);
  std::string* _internal_mutable_app_name();

  public:
  // string current_version = 3;
  void clear_current_version() ;
  const std::string& current_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_current_version(Arg_&& arg, Args_... args);
  std::string* mutable_current_version();
  PROTOBUF_NODISCARD std::string* release_current_version();
  void set_allocated_current_version(std::string* value);

  private:
  const std::string& _internal_current_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_current_version(
      const std::string& value);
  std::string* _internal_mutable_current_version();

  public:
  // int32 device_id = 1;
  void clear_device_id() ;
  ::int32_t device_id() const;
  void set_device_id(::int32_t value);

  private:
  ::int32_t _internal_device_id() const;
  void _internal_set_device_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ota.CheckUpdatesRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      55, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr app_name_;
    ::google::protobuf::internal::ArenaStringPtr current_version_;
    ::int32_t device_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ota_5fservice_2eproto;
};// -------------------------------------------------------------------

class CheckUpdatesResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ota.CheckUpdatesResponse) */ {
 public:
  inline CheckUpdatesResponse() : CheckUpdatesResponse(nullptr) {}
  ~CheckUpdatesResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CheckUpdatesResponse(::google::protobuf::internal::ConstantInitialized);

  inline CheckUpdatesResponse(const CheckUpdatesResponse& from)
      : CheckUpdatesResponse(nullptr, from) {}
  CheckUpdatesResponse(CheckUpdatesResponse&& from) noexcept
    : CheckUpdatesResponse() {
    *this = ::std::move(from);
  }

  inline CheckUpdatesResponse& operator=(const CheckUpdatesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckUpdatesResponse& operator=(CheckUpdatesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckUpdatesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckUpdatesResponse* internal_default_instance() {
    return reinterpret_cast<const CheckUpdatesResponse*>(
               &_CheckUpdatesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CheckUpdatesResponse& a, CheckUpdatesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckUpdatesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckUpdatesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckUpdatesResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckUpdatesResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CheckUpdatesResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CheckUpdatesResponse& from) {
    CheckUpdatesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CheckUpdatesResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ota.CheckUpdatesResponse";
  }
  protected:
  explicit CheckUpdatesResponse(::google::protobuf::Arena* arena);
  CheckUpdatesResponse(::google::protobuf::Arena* arena, const CheckUpdatesResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAvailableUpdatesFieldNumber = 1,
    kHasUpdatesFieldNumber = 2,
  };
  // repeated .ota.UpdateInfo available_updates = 1;
  int available_updates_size() const;
  private:
  int _internal_available_updates_size() const;

  public:
  void clear_available_updates() ;
  ::ota::UpdateInfo* mutable_available_updates(int index);
  ::google::protobuf::RepeatedPtrField< ::ota::UpdateInfo >*
      mutable_available_updates();
  private:
  const ::google::protobuf::RepeatedPtrField<::ota::UpdateInfo>& _internal_available_updates() const;
  ::google::protobuf::RepeatedPtrField<::ota::UpdateInfo>* _internal_mutable_available_updates();
  public:
  const ::ota::UpdateInfo& available_updates(int index) const;
  ::ota::UpdateInfo* add_available_updates();
  const ::google::protobuf::RepeatedPtrField< ::ota::UpdateInfo >&
      available_updates() const;
  // bool has_updates = 2;
  void clear_has_updates() ;
  bool has_updates() const;
  void set_has_updates(bool value);

  private:
  bool _internal_has_updates() const;
  void _internal_set_has_updates(bool value);

  public:
  // @@protoc_insertion_point(class_scope:ota.CheckUpdatesResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::ota::UpdateInfo > available_updates_;
    bool has_updates_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ota_5fservice_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// CheckUpdatesRequest

// int32 device_id = 1;
inline void CheckUpdatesRequest::clear_device_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_id_ = 0;
}
inline ::int32_t CheckUpdatesRequest::device_id() const {
  // @@protoc_insertion_point(field_get:ota.CheckUpdatesRequest.device_id)
  return _internal_device_id();
}
inline void CheckUpdatesRequest::set_device_id(::int32_t value) {
  _internal_set_device_id(value);
  // @@protoc_insertion_point(field_set:ota.CheckUpdatesRequest.device_id)
}
inline ::int32_t CheckUpdatesRequest::_internal_device_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.device_id_;
}
inline void CheckUpdatesRequest::_internal_set_device_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_id_ = value;
}

// string app_name = 2;
inline void CheckUpdatesRequest::clear_app_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.app_name_.ClearToEmpty();
}
inline const std::string& CheckUpdatesRequest::app_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ota.CheckUpdatesRequest.app_name)
  return _internal_app_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CheckUpdatesRequest::set_app_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ota.CheckUpdatesRequest.app_name)
}
inline std::string* CheckUpdatesRequest::mutable_app_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_app_name();
  // @@protoc_insertion_point(field_mutable:ota.CheckUpdatesRequest.app_name)
  return _s;
}
inline const std::string& CheckUpdatesRequest::_internal_app_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.app_name_.Get();
}
inline void CheckUpdatesRequest::_internal_set_app_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_name_.Set(value, GetArena());
}
inline std::string* CheckUpdatesRequest::_internal_mutable_app_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.app_name_.Mutable( GetArena());
}
inline std::string* CheckUpdatesRequest::release_app_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ota.CheckUpdatesRequest.app_name)
  return _impl_.app_name_.Release();
}
inline void CheckUpdatesRequest::set_allocated_app_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.app_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.app_name_.IsDefault()) {
          _impl_.app_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ota.CheckUpdatesRequest.app_name)
}

// string current_version = 3;
inline void CheckUpdatesRequest::clear_current_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.current_version_.ClearToEmpty();
}
inline const std::string& CheckUpdatesRequest::current_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ota.CheckUpdatesRequest.current_version)
  return _internal_current_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CheckUpdatesRequest::set_current_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.current_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ota.CheckUpdatesRequest.current_version)
}
inline std::string* CheckUpdatesRequest::mutable_current_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_current_version();
  // @@protoc_insertion_point(field_mutable:ota.CheckUpdatesRequest.current_version)
  return _s;
}
inline const std::string& CheckUpdatesRequest::_internal_current_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.current_version_.Get();
}
inline void CheckUpdatesRequest::_internal_set_current_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.current_version_.Set(value, GetArena());
}
inline std::string* CheckUpdatesRequest::_internal_mutable_current_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.current_version_.Mutable( GetArena());
}
inline std::string* CheckUpdatesRequest::release_current_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ota.CheckUpdatesRequest.current_version)
  return _impl_.current_version_.Release();
}
inline void CheckUpdatesRequest::set_allocated_current_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.current_version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.current_version_.IsDefault()) {
          _impl_.current_version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ota.CheckUpdatesRequest.current_version)
}

// -------------------------------------------------------------------

// UpdateInfo

// string app_name = 1;
inline void UpdateInfo::clear_app_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.app_name_.ClearToEmpty();
}
inline const std::string& UpdateInfo::app_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ota.UpdateInfo.app_name)
  return _internal_app_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateInfo::set_app_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ota.UpdateInfo.app_name)
}
inline std::string* UpdateInfo::mutable_app_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_app_name();
  // @@protoc_insertion_point(field_mutable:ota.UpdateInfo.app_name)
  return _s;
}
inline const std::string& UpdateInfo::_internal_app_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.app_name_.Get();
}
inline void UpdateInfo::_internal_set_app_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_name_.Set(value, GetArena());
}
inline std::string* UpdateInfo::_internal_mutable_app_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.app_name_.Mutable( GetArena());
}
inline std::string* UpdateInfo::release_app_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ota.UpdateInfo.app_name)
  return _impl_.app_name_.Release();
}
inline void UpdateInfo::set_allocated_app_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.app_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.app_name_.IsDefault()) {
          _impl_.app_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ota.UpdateInfo.app_name)
}

// string version = 2;
inline void UpdateInfo::clear_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.version_.ClearToEmpty();
}
inline const std::string& UpdateInfo::version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ota.UpdateInfo.version)
  return _internal_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateInfo::set_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ota.UpdateInfo.version)
}
inline std::string* UpdateInfo::mutable_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:ota.UpdateInfo.version)
  return _s;
}
inline const std::string& UpdateInfo::_internal_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.version_.Get();
}
inline void UpdateInfo::_internal_set_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.version_.Set(value, GetArena());
}
inline std::string* UpdateInfo::_internal_mutable_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.version_.Mutable( GetArena());
}
inline std::string* UpdateInfo::release_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ota.UpdateInfo.version)
  return _impl_.version_.Release();
}
inline void UpdateInfo::set_allocated_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.version_.IsDefault()) {
          _impl_.version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ota.UpdateInfo.version)
}

// string checksum = 3;
inline void UpdateInfo::clear_checksum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.checksum_.ClearToEmpty();
}
inline const std::string& UpdateInfo::checksum() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ota.UpdateInfo.checksum)
  return _internal_checksum();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateInfo::set_checksum(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.checksum_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ota.UpdateInfo.checksum)
}
inline std::string* UpdateInfo::mutable_checksum() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_checksum();
  // @@protoc_insertion_point(field_mutable:ota.UpdateInfo.checksum)
  return _s;
}
inline const std::string& UpdateInfo::_internal_checksum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.checksum_.Get();
}
inline void UpdateInfo::_internal_set_checksum(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.checksum_.Set(value, GetArena());
}
inline std::string* UpdateInfo::_internal_mutable_checksum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.checksum_.Mutable( GetArena());
}
inline std::string* UpdateInfo::release_checksum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ota.UpdateInfo.checksum)
  return _impl_.checksum_.Release();
}
inline void UpdateInfo::set_allocated_checksum(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.checksum_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.checksum_.IsDefault()) {
          _impl_.checksum_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ota.UpdateInfo.checksum)
}

// string target_path = 4;
inline void UpdateInfo::clear_target_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_path_.ClearToEmpty();
}
inline const std::string& UpdateInfo::target_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ota.UpdateInfo.target_path)
  return _internal_target_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateInfo::set_target_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ota.UpdateInfo.target_path)
}
inline std::string* UpdateInfo::mutable_target_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target_path();
  // @@protoc_insertion_point(field_mutable:ota.UpdateInfo.target_path)
  return _s;
}
inline const std::string& UpdateInfo::_internal_target_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.target_path_.Get();
}
inline void UpdateInfo::_internal_set_target_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_path_.Set(value, GetArena());
}
inline std::string* UpdateInfo::_internal_mutable_target_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.target_path_.Mutable( GetArena());
}
inline std::string* UpdateInfo::release_target_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ota.UpdateInfo.target_path)
  return _impl_.target_path_.Release();
}
inline void UpdateInfo::set_allocated_target_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.target_path_.IsDefault()) {
          _impl_.target_path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ota.UpdateInfo.target_path)
}

// -------------------------------------------------------------------

// CheckUpdatesResponse

// repeated .ota.UpdateInfo available_updates = 1;
inline int CheckUpdatesResponse::_internal_available_updates_size() const {
  return _internal_available_updates().size();
}
inline int CheckUpdatesResponse::available_updates_size() const {
  return _internal_available_updates_size();
}
inline void CheckUpdatesResponse::clear_available_updates() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.available_updates_.Clear();
}
inline ::ota::UpdateInfo* CheckUpdatesResponse::mutable_available_updates(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ota.CheckUpdatesResponse.available_updates)
  return _internal_mutable_available_updates()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::ota::UpdateInfo>* CheckUpdatesResponse::mutable_available_updates()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ota.CheckUpdatesResponse.available_updates)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_available_updates();
}
inline const ::ota::UpdateInfo& CheckUpdatesResponse::available_updates(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ota.CheckUpdatesResponse.available_updates)
  return _internal_available_updates().Get(index);
}
inline ::ota::UpdateInfo* CheckUpdatesResponse::add_available_updates() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::ota::UpdateInfo* _add = _internal_mutable_available_updates()->Add();
  // @@protoc_insertion_point(field_add:ota.CheckUpdatesResponse.available_updates)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::ota::UpdateInfo>& CheckUpdatesResponse::available_updates() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ota.CheckUpdatesResponse.available_updates)
  return _internal_available_updates();
}
inline const ::google::protobuf::RepeatedPtrField<::ota::UpdateInfo>&
CheckUpdatesResponse::_internal_available_updates() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.available_updates_;
}
inline ::google::protobuf::RepeatedPtrField<::ota::UpdateInfo>*
CheckUpdatesResponse::_internal_mutable_available_updates() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.available_updates_;
}

// bool has_updates = 2;
inline void CheckUpdatesResponse::clear_has_updates() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.has_updates_ = false;
}
inline bool CheckUpdatesResponse::has_updates() const {
  // @@protoc_insertion_point(field_get:ota.CheckUpdatesResponse.has_updates)
  return _internal_has_updates();
}
inline void CheckUpdatesResponse::set_has_updates(bool value) {
  _internal_set_has_updates(value);
  // @@protoc_insertion_point(field_set:ota.CheckUpdatesResponse.has_updates)
}
inline bool CheckUpdatesResponse::_internal_has_updates() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.has_updates_;
}
inline void CheckUpdatesResponse::_internal_set_has_updates(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.has_updates_ = value;
}

// -------------------------------------------------------------------

// DownloadRequest

// int32 device_id = 1;
inline void DownloadRequest::clear_device_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_id_ = 0;
}
inline ::int32_t DownloadRequest::device_id() const {
  // @@protoc_insertion_point(field_get:ota.DownloadRequest.device_id)
  return _internal_device_id();
}
inline void DownloadRequest::set_device_id(::int32_t value) {
  _internal_set_device_id(value);
  // @@protoc_insertion_point(field_set:ota.DownloadRequest.device_id)
}
inline ::int32_t DownloadRequest::_internal_device_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.device_id_;
}
inline void DownloadRequest::_internal_set_device_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_id_ = value;
}

// string app_name = 2;
inline void DownloadRequest::clear_app_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.app_name_.ClearToEmpty();
}
inline const std::string& DownloadRequest::app_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ota.DownloadRequest.app_name)
  return _internal_app_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DownloadRequest::set_app_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ota.DownloadRequest.app_name)
}
inline std::string* DownloadRequest::mutable_app_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_app_name();
  // @@protoc_insertion_point(field_mutable:ota.DownloadRequest.app_name)
  return _s;
}
inline const std::string& DownloadRequest::_internal_app_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.app_name_.Get();
}
inline void DownloadRequest::_internal_set_app_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_name_.Set(value, GetArena());
}
inline std::string* DownloadRequest::_internal_mutable_app_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.app_name_.Mutable( GetArena());
}
inline std::string* DownloadRequest::release_app_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ota.DownloadRequest.app_name)
  return _impl_.app_name_.Release();
}
inline void DownloadRequest::set_allocated_app_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.app_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.app_name_.IsDefault()) {
          _impl_.app_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ota.DownloadRequest.app_name)
}

// -------------------------------------------------------------------

// DownloadResponse

// bytes data = 1;
inline void DownloadResponse::clear_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.ClearToEmpty();
}
inline const std::string& DownloadResponse::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ota.DownloadResponse.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DownloadResponse::set_data(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ota.DownloadResponse.data)
}
inline std::string* DownloadResponse::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:ota.DownloadResponse.data)
  return _s;
}
inline const std::string& DownloadResponse::_internal_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_.Get();
}
inline void DownloadResponse::_internal_set_data(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.data_.Set(value, GetArena());
}
inline std::string* DownloadResponse::_internal_mutable_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.data_.Mutable( GetArena());
}
inline std::string* DownloadResponse::release_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ota.DownloadResponse.data)
  return _impl_.data_.Release();
}
inline void DownloadResponse::set_allocated_data(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_.IsDefault()) {
          _impl_.data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ota.DownloadResponse.data)
}

// int64 total_size = 2;
inline void DownloadResponse::clear_total_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.total_size_ = ::int64_t{0};
}
inline ::int64_t DownloadResponse::total_size() const {
  // @@protoc_insertion_point(field_get:ota.DownloadResponse.total_size)
  return _internal_total_size();
}
inline void DownloadResponse::set_total_size(::int64_t value) {
  _internal_set_total_size(value);
  // @@protoc_insertion_point(field_set:ota.DownloadResponse.total_size)
}
inline ::int64_t DownloadResponse::_internal_total_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_size_;
}
inline void DownloadResponse::_internal_set_total_size(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.total_size_ = value;
}

// int64 current_size = 3;
inline void DownloadResponse::clear_current_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.current_size_ = ::int64_t{0};
}
inline ::int64_t DownloadResponse::current_size() const {
  // @@protoc_insertion_point(field_get:ota.DownloadResponse.current_size)
  return _internal_current_size();
}
inline void DownloadResponse::set_current_size(::int64_t value) {
  _internal_set_current_size(value);
  // @@protoc_insertion_point(field_set:ota.DownloadResponse.current_size)
}
inline ::int64_t DownloadResponse::_internal_current_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.current_size_;
}
inline void DownloadResponse::_internal_set_current_size(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.current_size_ = value;
}

// -------------------------------------------------------------------

// StatusReport

// int32 device_id = 1;
inline void StatusReport::clear_device_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_id_ = 0;
}
inline ::int32_t StatusReport::device_id() const {
  // @@protoc_insertion_point(field_get:ota.StatusReport.device_id)
  return _internal_device_id();
}
inline void StatusReport::set_device_id(::int32_t value) {
  _internal_set_device_id(value);
  // @@protoc_insertion_point(field_set:ota.StatusReport.device_id)
}
inline ::int32_t StatusReport::_internal_device_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.device_id_;
}
inline void StatusReport::_internal_set_device_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_id_ = value;
}

// string app_name = 2;
inline void StatusReport::clear_app_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.app_name_.ClearToEmpty();
}
inline const std::string& StatusReport::app_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ota.StatusReport.app_name)
  return _internal_app_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StatusReport::set_app_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ota.StatusReport.app_name)
}
inline std::string* StatusReport::mutable_app_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_app_name();
  // @@protoc_insertion_point(field_mutable:ota.StatusReport.app_name)
  return _s;
}
inline const std::string& StatusReport::_internal_app_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.app_name_.Get();
}
inline void StatusReport::_internal_set_app_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_name_.Set(value, GetArena());
}
inline std::string* StatusReport::_internal_mutable_app_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.app_name_.Mutable( GetArena());
}
inline std::string* StatusReport::release_app_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ota.StatusReport.app_name)
  return _impl_.app_name_.Release();
}
inline void StatusReport::set_allocated_app_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.app_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.app_name_.IsDefault()) {
          _impl_.app_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ota.StatusReport.app_name)
}

// string status = 3;
inline void StatusReport::clear_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_.ClearToEmpty();
}
inline const std::string& StatusReport::status() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ota.StatusReport.status)
  return _internal_status();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StatusReport::set_status(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.status_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ota.StatusReport.status)
}
inline std::string* StatusReport::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:ota.StatusReport.status)
  return _s;
}
inline const std::string& StatusReport::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.status_.Get();
}
inline void StatusReport::_internal_set_status(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.status_.Set(value, GetArena());
}
inline std::string* StatusReport::_internal_mutable_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.status_.Mutable( GetArena());
}
inline std::string* StatusReport::release_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ota.StatusReport.status)
  return _impl_.status_.Release();
}
inline void StatusReport::set_allocated_status(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.status_.IsDefault()) {
          _impl_.status_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ota.StatusReport.status)
}

// string error_message = 4;
inline void StatusReport::clear_error_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& StatusReport::error_message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ota.StatusReport.error_message)
  return _internal_error_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StatusReport::set_error_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.error_message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ota.StatusReport.error_message)
}
inline std::string* StatusReport::mutable_error_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:ota.StatusReport.error_message)
  return _s;
}
inline const std::string& StatusReport::_internal_error_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.error_message_.Get();
}
inline void StatusReport::_internal_set_error_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.error_message_.Set(value, GetArena());
}
inline std::string* StatusReport::_internal_mutable_error_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.error_message_.Mutable( GetArena());
}
inline std::string* StatusReport::release_error_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ota.StatusReport.error_message)
  return _impl_.error_message_.Release();
}
inline void StatusReport::set_allocated_error_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_message_.IsDefault()) {
          _impl_.error_message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ota.StatusReport.error_message)
}

// string version = 5;
inline void StatusReport::clear_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.version_.ClearToEmpty();
}
inline const std::string& StatusReport::version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ota.StatusReport.version)
  return _internal_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StatusReport::set_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ota.StatusReport.version)
}
inline std::string* StatusReport::mutable_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:ota.StatusReport.version)
  return _s;
}
inline const std::string& StatusReport::_internal_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.version_.Get();
}
inline void StatusReport::_internal_set_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.version_.Set(value, GetArena());
}
inline std::string* StatusReport::_internal_mutable_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.version_.Mutable( GetArena());
}
inline std::string* StatusReport::release_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ota.StatusReport.version)
  return _impl_.version_.Release();
}
inline void StatusReport::set_allocated_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.version_.IsDefault()) {
          _impl_.version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ota.StatusReport.version)
}

// -------------------------------------------------------------------

// StatusResponse

// bool success = 1;
inline void StatusResponse::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool StatusResponse::success() const {
  // @@protoc_insertion_point(field_get:ota.StatusResponse.success)
  return _internal_success();
}
inline void StatusResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:ota.StatusResponse.success)
}
inline bool StatusResponse::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void StatusResponse::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.success_ = value;
}

// string message = 2;
inline void StatusResponse::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& StatusResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ota.StatusResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StatusResponse::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ota.StatusResponse.message)
}
inline std::string* StatusResponse::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:ota.StatusResponse.message)
  return _s;
}
inline const std::string& StatusResponse::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void StatusResponse::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* StatusResponse::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* StatusResponse::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ota.StatusResponse.message)
  return _impl_.message_.Release();
}
inline void StatusResponse::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ota.StatusResponse.message)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace ota


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_ota_5fservice_2eproto_2epb_2eh
